<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leo Zhao &#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhaoleyi.github.io/"/>
  <updated>2016-08-26T04:26:06.845Z</updated>
  <id>http://zhaoleyi.github.io/</id>
  
  <author>
    <name>Leo Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>讲课作业补全记</title>
    <link href="http://zhaoleyi.github.io/2016/08/25/%E8%AE%B2%E8%AF%BE%E4%BD%9C%E4%B8%9A%E8%A1%A5%E5%85%A8%E8%AE%B0/"/>
    <id>http://zhaoleyi.github.io/2016/08/25/讲课作业补全记/</id>
    <published>2016-08-25T11:47:36.000Z</published>
    <updated>2016-08-26T04:26:06.845Z</updated>
    
    <content type="html">&lt;p&gt;也许人太弱是因为之前都没有做作业，所以我要变强也许应该先补全作业，来来来补作业计划开始了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;dp入门&quot;&gt;&lt;a href=&quot;#dp入门&quot; class=&quot;headerlink&quot; title=&quot;dp入门&quot;&gt;&lt;/a&gt;dp入门&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于我的dp技术非常不行，所以我先从dp入手  &lt;/p&gt;
&lt;h2 id=&quot;T1&quot;&gt;&lt;a href=&quot;#T1&quot; class=&quot;headerlink&quot; title=&quot;T1&quot;&gt;&lt;/a&gt;T1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/446/problem/A&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;题面的意思大概是给你一串数列，在改变其中的一个数的情况下，求得可以产生的最长的严格递增的数列的长度&lt;br&gt;&lt;em&gt;不要虚，这题还是比较简单的，所以静静的想5分钟吧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;1分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;2分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;3分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;4分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;5分钟&lt;/big&gt;&lt;/p&gt;&lt;br&gt;时间到。具体就是用f1[x]表示以x结尾的最大严格升序连续串，f2[x]表示以x开头的最大严格升序连续串然后瞎jb搞一下就可以了具体看代码吧&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; N 100005&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ch=getchar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ch&amp;lt;&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;||ch&amp;gt;&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)ch=getchar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ch&amp;gt;=&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;&amp;amp;&amp;amp;ch&amp;lt;=&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)x=x*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+ch-&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,ch=getchar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,a[N],f1[N],f2[N];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	n=read();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 a[i]=read();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	f1[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i]&amp;gt;a[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])f1[i]=f1[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; f1[i]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	f2[n]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i&amp;gt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i--)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i]&amp;lt;a[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])f2[i]=f2[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; f2[i]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans=max(f2[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,f1[n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&amp;lt;a[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)ans=max(ans,f1[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+f2[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; ans=max(ans,max(f1[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,f2[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,ans);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;T2&quot;&gt;&lt;a href=&quot;#T2&quot; class=&quot;headerlink&quot; title=&quot;T2&quot;&gt;&lt;/a&gt;T2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/463/problem/D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;这题的题意大概是给你k个n的排列，求他们的最长公共子序列的长度是多少。还是老样子，先想5分钟&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;1分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;2分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;3分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;4分钟&lt;/big&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;big&gt;5分钟&lt;/big&gt;&lt;/p&gt;&lt;br&gt;好，时间到了，这题可以用图论的最长路来做：先一把{n}^{2}的预处理，如果有每一个全排列的数字x都在数字y的前面，那么x，y建立一条有向边。之后先建立一个超级原点连向所有的n个点，再建立一个超级汇点，使得所有的n个点都连向它。然后要注意的是这两条边的边权都是0。再跑一遍spfa算法，求得从超级原点到超级汇点的最长路，记得答案还要+1。&lt;br&gt;具体详见代码&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,K,a[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;5005&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; edge&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; to,next,val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;e[&lt;span class=&quot;number&quot;&gt;1005&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1005&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//一点要注意边数要开到n^2级别的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; g[&lt;span class=&quot;number&quot;&gt;5005&lt;/span&gt;],cnt=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,q[&lt;span class=&quot;number&quot;&gt;1005&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1005&lt;/span&gt;],dis[&lt;span class=&quot;number&quot;&gt;5005&lt;/span&gt;],f[&lt;span class=&quot;number&quot;&gt;5005&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//队列大小也要开打&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,f=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ch=getchar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ch&amp;lt;&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;||ch&amp;gt;&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ch==&lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;)f=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;ch=getchar();&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ch&amp;gt;=&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;&amp;amp;&amp;amp;ch&amp;lt;=&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)x=x*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+ch-&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,ch=getchar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x*f;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; z)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cnt++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e[cnt].to=y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e[cnt].next=g[x];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e[cnt].val=z;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    g[x]=cnt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spfa&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(dis,&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(dis));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,u,v,h=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,t=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    q[t]=s,dis[s]=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,f[s]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(h&amp;lt;=t)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (f[u=q[h++]]=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i=g[u];i;i=e[i].next)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((v=e[i].to)&amp;amp;&amp;amp;dis[u]+e[i].val&amp;gt;dis[v])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             dis[v]=dis[u]+e[i].val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!f[v])q[++t]=v,f[v]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=K;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i][x]&amp;gt;=a[i][y])&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    n=read();K=read();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=K;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;=n;j++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#123;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x=read();a[i][x]=j;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;=n;j++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (check(i,j))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       insert(i,j,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),insert(i,n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    spfa(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;=n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     ans=max(ans,dis[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,ans+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;也许人太弱是因为之前都没有做作业，所以我要变强也许应该先补全作业，来来来补作业计划开始了&lt;br&gt;
    
    </summary>
    
    
      <category term="变强" scheme="http://zhaoleyi.github.io/tags/%E5%8F%98%E5%BC%BA/"/>
    
      <category term="日常日记" scheme="http://zhaoleyi.github.io/tags/%E6%97%A5%E5%B8%B8%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="http://zhaoleyi.github.io/2016/08/15/%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://zhaoleyi.github.io/2016/08/15/一个新的开始/</id>
    <published>2016-08-15T14:28:48.000Z</published>
    <updated>2016-08-15T15:01:23.939Z</updated>
    
    <content type="html">&lt;p&gt;时间过得好快呀，转眼间我上一次的博客更新都是4月份的事情了，突然发现自己现在这半年也没干什么，心里一阵酸楚&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;今天心血来潮了一下，在新电脑上重新配置了一下ssh和hexo，突然发现我好像已经很久没有写过博客了自己的姿势水平好像也很久没有提高了😩说好的6月份变强也只有慢慢地去实现了。&lt;br&gt;一转眼就是暑假过了，开始上学了，但是我好像还是很迷茫：对于两者的平衡；对于下半年决定明年命运的noip提高组联赛。&lt;br&gt;虽然在大一中这样一个团体里，还是有很多值得学习的学长的比较好的经历在前面：&lt;strong&gt;比如大圣&lt;/strong&gt;。但是我也不可否认的是也许我目前对于这种的学习方法还是不可以找到属于自己的最高效的节奏。&lt;br&gt;&lt;del&gt;花老师&lt;/del&gt;曾经跟我们说过在这半年里要努力学算法，努力往上冲但是我其实发现他的建议并不是全对，比如我自己虽然说自称会打很多算法的板子，但是其实在模拟赛里还是在很多的时候没有办法去想到它，有时候即使想到了，它的细节处理和码量有时候也会让我望而却步，甚至连暴力都没有打。所以我要立下几个flag，在之后的模拟赛中去克服这个问题。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我从现在开始要多刷题，特别是多刷希彦题，争取努力跟跟神犇们的脚步，改变先从题目数量开始  &lt;/li&gt;
&lt;li&gt;还有从现在开始我做模拟赛的时候不要再懒了，要把自己可以拿的分数全部都拿好，先努力像吴穹学长说的一样，想拿省一等，先每次的模拟赛都考200+&lt;/li&gt;
&lt;li&gt;还有就是隔膜的问题，我会努力的控制，在平时的时候不打隔膜，偶尔手痒了，双休日的时候定时打几把&lt;br&gt;我想，也许这样才会让我变强，让浪逼的悲剧不再重演  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;大家一起勉励&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;i&gt;记于一个开学后迷茫的深夜&lt;/i&gt;&lt;/p&gt;&lt;br&gt;&lt;p align=&quot;right&quot;&gt;&lt;i&gt;2016年8月15日23点整，从现在开始改变自己&lt;/i&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;时间过得好快呀，转眼间我上一次的博客更新都是4月份的事情了，突然发现自己现在这半年也没干什么，心里一阵酸楚&lt;br&gt;
    
    </summary>
    
    
      <category term="日常日记" scheme="http://zhaoleyi.github.io/tags/%E6%97%A5%E5%B8%B8%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SPFA算法详解</title>
    <link href="http://zhaoleyi.github.io/2016/04/21/SPFA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhaoleyi.github.io/2016/04/21/SPFA算法详解/</id>
    <published>2016-04-21T07:28:41.000Z</published>
    <updated>2016-04-21T09:35:26.513Z</updated>
    
    <content type="html">&lt;p&gt;现在是2016年4月21日，今天我学习了不少奇奇怪怪的算法，同时还为我的博客增加了mathJax支持。此文是一篇关于SPFA算法的归纳，部分内容转载，不喜勿喷&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;                                    &lt;/p&gt;&lt;p&gt;适用范围：给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。 我们约定有向加权图G不存在负权回路，即最短路径一定存在。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路，但这不是我们讨论的重点。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;算法思想：我们用数组d记录每个结点的最短路径估计值，用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;实现方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　建立一个队列，初始时队列里只有起始点，再建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点作为起始点去刷新到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;判断有无负环：&lt;br&gt;&lt;br&gt;　　如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_1.png&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先建立起始点a到其余各点的&lt;br&gt;&lt;br&gt;最短路径表格&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_2.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先源点a入队，当队列非空时：&lt;br&gt;&lt;br&gt;　１、队首元素（a）出队，对以a为起始点的所有边的终点依次进行松弛操作（此处有b,c,d三个点），此时路径表格状态为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_3.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在松弛时三个点的最短路径估值变小了，而这些点队列中都没有出现，这些点&lt;br&gt;&lt;br&gt;需要入队，此时，队列中新入队了三个结点b,c,d&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e点），此时路径表格状态为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_4.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，e的最短路径估值也变小了，e在队列中不存在，因此e也要&lt;br&gt;&lt;br&gt;入队，此时队列中的元素为c，d，e&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;队首元素c点出队，对以c为起始点的所有边的终点依次进行松弛操作（此处有e,f两个点），此时路径表格状态为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_5.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，e，f的最短路径估值变小了，e在队列中存在，f不存在。因此&lt;br&gt;&lt;br&gt;e不用入队了，f要入队，此时队列中的元素为d，e，f&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;队首元素d点出队，对以d为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_6.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，g的最短路径估值没有变小（松弛不成功），没有新结点入队，队列中元素为f，g&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;队首元素f点出队，对以f为起始点的所有边的终点依次进行松弛操作（此处有d，e，g三个点），此时路径表格状态为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_7.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，e，g的最短路径估值又变小，队列中无e点，e入队，队列中存在g这个点，g不用入队，此时队列中元素为g，e&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;队首元素g点出队，对以g为起始点的所有边的终点依次进行松弛操作（此处只有b点），此时路径表格状态为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_8.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，b的最短路径估值又变小，队列中无b点，b入队，此时队列中元素为e，b&lt;br&gt;&lt;br&gt;队首元素e点出队，对以e为起始点的所有边的终点依次进行松弛操作（此处只有g这个点），此时路径表格状态为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_9.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，g的最短路径估值没变化（松弛不成功），此时队列中元素为b&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;队首元素b点出队，对以b为起始点的所有边的终点依次进行松弛操作（此处只有e这个点），此时路径表格状态为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;img alt=&quot;&quot; src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/37315024_9.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;在最短路径表中，e的最短路径估值没变化（松弛不成功），此时队列为空了&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;最终a到g的最短路径为１４&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;program：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;#include&amp;lt;cstdio&amp;gt;&lt;br&gt;&lt;br&gt;using namespace std;&lt;br&gt;&lt;br&gt;struct node&lt;br&gt;&lt;br&gt;{int x;&lt;br&gt;&lt;br&gt;&amp;nbsp;int value;&lt;br&gt;&lt;br&gt;&amp;nbsp;int next;&lt;br&gt;&lt;br&gt;};&lt;br&gt;&lt;br&gt;node e[60000];&lt;br&gt;&lt;br&gt;int visited[1505],dis[1505],st[1505],queue[1000];&lt;br&gt;&lt;br&gt;int main()&lt;br&gt;&lt;br&gt;{&lt;br&gt;&lt;br&gt;&amp;nbsp; int n,m,u,v,w,start,h,r,cur;&lt;br&gt;&lt;br&gt;&amp;nbsp; freopen(“c.in”,”r”,stdin);&lt;br&gt;&lt;br&gt;&amp;nbsp; freopen(“c.out”,”w”,stdout); &lt;br&gt;&lt;br&gt;&amp;nbsp; while(scanf(“%d%d”,&amp;amp;n,&amp;amp;m)!=EOF)&lt;br&gt;&lt;br&gt;&amp;nbsp; {&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for(int i=1;i&amp;lt;=1500;i++)&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {visited[i]=0;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[i]=-1;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; st[i]=-1;&amp;nbsp; //这个初始化给下边那个while循环带来影响&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp; for(int i=1;i&amp;lt;=m;i++)&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; scanf(“%d%d%d\n”,&amp;amp;u,&amp;amp;v,&amp;amp;w);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; e[i].x=v;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //记录后继节点&amp;nbsp;&amp;nbsp;&amp;nbsp; 相当于链表中的创建一个节点，并使得数据域先记录&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; e[i].value=w;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; e[i].next=st[u];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //记录顶点节点的某一个边表节点的下标，相当于在链表中吧该边表节点的next指针先指向他的后继边表节点&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; st[u]=i;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //把该顶点的指针指向边表节点，相当于链表中的插入中，头结点的指针改变&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; start=1;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; visited[start]=1;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[start]=0;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; h=0;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; r=1;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; queue[r]=start;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(h!=r)&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; h=(h+1)%1000;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cur=queue[h];&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int tmp=st[cur];&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; visited[cur]=0;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while(tmp!=-1)&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;if (dis[e[tmp].x]&amp;lt;dis[cur]+e[tmp].value)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //改成大于号才对&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;{&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[e[tmp].x]=dis[cur]+e[tmp].value;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; if(visited[e[tmp].x]==0)&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;visited[e[tmp].x]=1;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;r=(r+1)%1000;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; queue[r]=e[tmp].x;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;}&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; tmp=e[tmp].next;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } &lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; printf(“%d\n”,dis[n]);&lt;br&gt;&lt;br&gt;&amp;nbsp; }&lt;br&gt;&lt;br&gt;&amp;nbsp; return 0;&amp;nbsp;&amp;nbsp; &lt;br&gt;&lt;br&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(没有质量，就出数量)&amp;nbsp; 下面一文转载出处：&lt;a href=&quot;http://blog.csdn.net/morgan_xww/article/details/6279596&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/morgan_xww/article/details/6279596&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;div&gt;

&lt;p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;/&lt;em&gt; &lt;/em&gt;&lt;/li&gt;&lt;li&gt;SPFA(Shortest Path Faster Algorithm) [图的存储方式为邻接表]&lt;/li&gt;&lt;li&gt;是Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。&lt;/li&gt;&lt;li&gt;算法大致流程是用一个队列来进行维护。 初始时将源加入队列。 每次从队列中取出一个元素，&lt;/li&gt;&lt;li&gt;并对所有与他相邻的点进行松弛，若某个相邻的点松弛成功，则将其入队。 直到队列为空时算法结束。&lt;/li&gt;&lt;li&gt;它可以在O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。&lt;br&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;SPFA 在形式上和BFS非常类似，不同的是BFS中一个点出了队列就不可能重新进入队列，但是SPFA中&lt;/li&gt;&lt;li&gt;一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本&lt;/li&gt;&lt;li&gt;身被改进，于是再次用来改进其它的点，这样反复迭代下去。 &lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;判断有无负环：如果某个点进入队列的次数超过V次则存在负环（SPFA无法处理带负环的图）。&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;SPFA算法有两个优化算法 SLF 和 LLL： &lt;/li&gt;&lt;li&gt;SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j)&amp;lt;dist(i)，则将j插入队首，&lt;/li&gt;&lt;li&gt;否则插入队尾。 &lt;/li&gt;&lt;li&gt;LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，若dist(i)&amp;gt;x则将i插入&lt;/li&gt;&lt;li&gt;到队尾，查找下一元素，直到找到某一i使得dist(i)&amp;lt;=x，则将i出对进行松弛操作。&lt;/li&gt;&lt;li&gt;引用网上资料，SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%。&lt;/li&gt;&lt;li&gt;在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。&lt;/li&gt;&lt;li&gt;/&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;//用数组实现邻接表存储，pnt[i,0]表示与i相邻的结点个数，pnt[i,1…k]存储与i相邻的点&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp; pnt[MAXN][MAXN];&amp;nbsp; &lt;/li&gt;&lt;li&gt;int&amp;nbsp; map[MAXN][MAXN];&lt;br&gt;//map[i,j]为初始输入的i到j的距离，并且map[i,i]=0;未知的map[i,j]=INF;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp; dis[MAXN];&amp;nbsp; &lt;/li&gt;&lt;li&gt;char vst[MAXN];&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;int SPFA(int n,int s)&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int i, pri, end, p, t;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; memset(vst, 0, sizeof(vst));&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i=1; i&amp;lt;=n; i++)&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[i] = INF;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[s] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[s] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[0] = s; pri = 0; end = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; while (pri &amp;lt; end)&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; p = Q[pri];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i=1; i&amp;lt;=pnt[p][0]; i++)&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; t = pnt[p][i];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //先释放，释放成功后再判断是否要加入队列&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (dis[p]+map[p][t] &amp;lt; dis[t])&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[t] = dis[p]+map[p][t];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!vst[t])&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[end++] = t;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[t] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[p] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pri++;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;}&amp;nbsp; &lt;/li&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;/&lt;em&gt;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;SPFA(Shortest&amp;nbsp;Path&amp;nbsp;Faster&amp;nbsp;Algorithm)&amp;nbsp;[图的存储方式为邻接表]&amp;nbsp;&lt;/li&gt;&lt;li&gt;是Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。&amp;nbsp;&lt;/li&gt;&lt;li&gt;算法大致流程是用一个队列来进行维护。&amp;nbsp;初始时将源加入队列。&amp;nbsp;每次从队列中取出一个元素，&amp;nbsp;&lt;/li&gt;&lt;li&gt;并对所有与他相邻的点进行松弛，若某个相邻的点松弛成功，则将其入队。&amp;nbsp;直到队列为空时算法结束。&amp;nbsp;&lt;/li&gt;&lt;li&gt;它可以在O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&lt;/li&gt;&lt;li&gt;SPFA&amp;nbsp;在形式上和BFS非常类似，不同的是BFS中一个点出了队列就不可能重新进入队列，但是SPFA中&amp;nbsp;&lt;/li&gt;&lt;li&gt;一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本&amp;nbsp;&lt;/li&gt;&lt;li&gt;身被改进，于是再次用来改进其它的点，这样反复迭代下去。&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&lt;/li&gt;&lt;li&gt;判断有无负环：如果某个点进入队列的次数超过V次则存在负环（SPFA无法处理带负环的图）。&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&lt;/li&gt;&lt;li&gt;SPFA算法有两个优化算法&amp;nbsp;SLF&amp;nbsp;和&amp;nbsp;LLL：&amp;nbsp;&lt;/li&gt;&lt;li&gt;SLF：Small&amp;nbsp;Label&amp;nbsp;First&amp;nbsp;策略，设要加入的节点是j，队首元素为i，若dist(j)&amp;lt;dist(i)，则将j插入队首，&amp;nbsp;&lt;/li&gt;&lt;li&gt;否则插入队尾。&amp;nbsp;&lt;/li&gt;&lt;li&gt;LLL：Large&amp;nbsp;Label&amp;nbsp;Last&amp;nbsp;策略，设队首元素为i，队列中所有dist值的平均值为x，若dist(i)&amp;gt;x则将i插入&amp;nbsp;&lt;/li&gt;&lt;li&gt;到队尾，查找下一元素，直到找到某一i使得dist(i)&amp;lt;=x，则将i出对进行松弛操作。&amp;nbsp;&lt;/li&gt;&lt;li&gt;引用网上资料，SLF&amp;nbsp;可使速度提高&amp;nbsp;15&amp;nbsp;~&amp;nbsp;20%；SLF&amp;nbsp;+&amp;nbsp;LLL&amp;nbsp;可提高约&amp;nbsp;50%。&amp;nbsp;&lt;/li&gt;&lt;li&gt;在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;//用数组实现邻接表存储，pnt[i,0]表示与i相邻的结点个数，pnt[i,1…k]存储与i相邻的点&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;&amp;nbsp;pnt[MAXN][MAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;&amp;nbsp;map[MAXN][MAXN];&amp;nbsp;//map[i,j]为初始输入的i到j的距离，并且map[i,i]=0;未知的map[i,j]=INF;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;&amp;nbsp;dis[MAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;char&amp;nbsp;vst[MAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;SPFA(int&amp;nbsp;n,&amp;nbsp;int&amp;nbsp;s)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;i,&amp;nbsp;pri,&amp;nbsp;end,&amp;nbsp;p,&amp;nbsp;t;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memset(vst,&amp;nbsp;0,&amp;nbsp;sizeof(vst));&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(i=1;&amp;nbsp;i&amp;lt;=n;&amp;nbsp;i++)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[i]&amp;nbsp;=&amp;nbsp;INF;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[s]&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[s]&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Q[0]&amp;nbsp;=&amp;nbsp;s;&amp;nbsp;pri&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;end&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(pri&amp;nbsp;&amp;lt;&amp;nbsp;end)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;Q[pri];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(i=1;&amp;nbsp;i&amp;lt;=pnt[p][0];&amp;nbsp;i++)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t&amp;nbsp;=&amp;nbsp;pnt[p][i];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//先释放，释放成功后再判断是否要加入队列&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(dis[p]+map[p][t]&amp;nbsp;&amp;lt;&amp;nbsp;dis[t])&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[t]&amp;nbsp;=&amp;nbsp;dis[p]+map[p][t];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(!vst[t])&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Q[end++]&amp;nbsp;=&amp;nbsp;t;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[t]&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[p]&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pri++;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/p&gt;
&lt;div&gt;

&lt;p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;正规邻接表存储：&amp;nbsp; &lt;/li&gt;&lt;li&gt;/&lt;em&gt; ——- 邻接表存储 ———– &lt;/em&gt;/&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;struct Edge&amp;nbsp; &lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int e;&amp;nbsp; //终点&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int v;&amp;nbsp; //边权&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct Edge &lt;em&gt;nxt;&amp;nbsp;&lt;br&gt;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;};&amp;nbsp; &lt;/li&gt;&lt;li&gt;struct&amp;nbsp; &lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct Edge head, &lt;em&gt;last;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;} node[MAXN];&amp;nbsp; &lt;/li&gt;&lt;li&gt;/ ——————————– &lt;em&gt;/&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;/&amp;nbsp; 添加有向边&amp;lt;起点,终点,边权&amp;gt;&amp;nbsp; &lt;em&gt;/&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;void add(int s,int e,int v)&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct Edge p;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; p = (struct Edge&lt;em&gt;)malloc(sizeof(struct Edge));&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; p-&amp;gt;e = e;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; p-&amp;gt;v = v;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; p-&amp;gt;nxt = NULL;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (node[s].head == NULL)&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; node[s].head = p;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; node[s].last = p;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; node[s].last-&amp;gt;nxt = p;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; node[s].last = p;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;}&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;/&amp;nbsp; 松弛，成功返回1，否则0&amp;nbsp; &lt;em&gt;/&amp;nbsp;&lt;br&gt;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;int relax(int s,int e,int v)&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (dis[s]+v &amp;lt; dis[e])&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[e] = dis[s]+v;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 1;&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;}&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;/&amp;nbsp; SPFA有负权回路返回0,否则返回1并且最短路径保存在dis[]&amp;nbsp; &lt;em&gt;/&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;int n;&amp;nbsp; &lt;/li&gt;&lt;li&gt;int vst[MAXN], cnt[MAXN];&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;int Q[MAXNMAXN];&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;int SPFA(int s0)&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int i, p, q;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct Edge *pp;&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; memset(vst, 0, sizeof(vst));&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; memset(cnt, 0, sizeof(cnt));&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i=0; i&amp;lt;=n; i++)&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[i] = INF;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[s0] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[0] = s0; p = 0; q = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[s0] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; cnt[s0]++;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; while (p &amp;lt; q)&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pp = node[Q[p]].head;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while (pp)&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (relax(Q[p], pp-&amp;gt;e, pp-&amp;gt;v) &amp;amp;&amp;amp; !vst[pp-&amp;gt;e])&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[q++] = pp-&amp;gt;e;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[pp-&amp;gt;e] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; cnt[pp-&amp;gt;e]++;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (cnt[pp-&amp;gt;e] &amp;gt; n)&lt;br&gt;//有负权回路&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 0;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pp = pp-&amp;gt;nxt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[Q[p]] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; p++;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;}&amp;nbsp; &lt;/li&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;正规邻接表存储：&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&lt;em&gt;&amp;nbsp;——-&amp;nbsp;邻接表存储&amp;nbsp;———–&amp;nbsp;&lt;/em&gt;/&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;struct&amp;nbsp;Edge&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;e;&amp;nbsp;&amp;nbsp;//终点&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;v;&amp;nbsp;&amp;nbsp;//边权&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct&amp;nbsp;Edge&amp;nbsp;&lt;em&gt;nxt;&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;};&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;struct&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct&amp;nbsp;Edge&amp;nbsp;head,&amp;nbsp;&lt;em&gt;last;&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;}&amp;nbsp;node[MAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&amp;nbsp;——————————–&amp;nbsp;&lt;em&gt;/&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&amp;nbsp;&amp;nbsp;添加有向边&amp;lt;起点,终点,边权&amp;gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;/&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;void&amp;nbsp;add(int&amp;nbsp;s,&amp;nbsp;int&amp;nbsp;e,&amp;nbsp;int&amp;nbsp;v)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct&amp;nbsp;Edge&amp;nbsp;p;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;(struct&amp;nbsp;Edge&lt;em&gt;)malloc(sizeof(struct&amp;nbsp;Edge));&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p-&amp;gt;e&amp;nbsp;=&amp;nbsp;e;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p-&amp;gt;v&amp;nbsp;=&amp;nbsp;v;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p-&amp;gt;nxt&amp;nbsp;=&amp;nbsp;NULL;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(node[s].head&amp;nbsp;==&amp;nbsp;NULL)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;node[s].head&amp;nbsp;=&amp;nbsp;p;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;node[s].last&amp;nbsp;=&amp;nbsp;p;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;node[s].last-&amp;gt;nxt&amp;nbsp;=&amp;nbsp;p;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;node[s].last&amp;nbsp;=&amp;nbsp;p;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&amp;nbsp;&amp;nbsp;松弛，成功返回1，否则0&amp;nbsp;&amp;nbsp;&lt;em&gt;/&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;relax(int&amp;nbsp;s,&amp;nbsp;int&amp;nbsp;e,&amp;nbsp;int&amp;nbsp;v)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(dis[s]+v&amp;nbsp;&amp;lt;&amp;nbsp;dis[e])&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[e]&amp;nbsp;=&amp;nbsp;dis[s]+v;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;/&amp;nbsp;&amp;nbsp;SPFA有负权回路返回0,否则返回1并且最短路径保存在dis[]&amp;nbsp;&amp;nbsp;&lt;em&gt;/&amp;nbsp;&amp;nbsp;&lt;/em&gt;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;n;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;vst[MAXN],&amp;nbsp;cnt[MAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;Q[MAXNMAXN];&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;int&amp;nbsp;SPFA(int&amp;nbsp;s0)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;i,&amp;nbsp;p,&amp;nbsp;q;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct&amp;nbsp;Edge&amp;nbsp;*pp;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memset(vst,&amp;nbsp;0,&amp;nbsp;sizeof(vst));&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memset(cnt,&amp;nbsp;0,&amp;nbsp;sizeof(cnt));&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(i=0;&amp;nbsp;i&amp;lt;=n;&amp;nbsp;i++)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[i]&amp;nbsp;=&amp;nbsp;INF;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dis[s0]&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Q[0]&amp;nbsp;=&amp;nbsp;s0;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;q&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[s0]&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cnt[s0]++;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(p&amp;nbsp;&amp;lt;&amp;nbsp;q)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pp&amp;nbsp;=&amp;nbsp;node[Q[p]].head;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(pp)&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(relax(Q[p],&amp;nbsp;pp-&amp;gt;e,&amp;nbsp;pp-&amp;gt;v)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;!vst[pp-&amp;gt;e])&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Q[q++]&amp;nbsp;=&amp;nbsp;pp-&amp;gt;e;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[pp-&amp;gt;e]&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cnt[pp-&amp;gt;e]++;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(cnt[pp-&amp;gt;e]&amp;nbsp;&amp;gt;&amp;nbsp;n)&amp;nbsp;//有负权回路&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pp&amp;nbsp;=&amp;nbsp;pp-&amp;gt;nxt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vst[Q[p]]&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p++;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;1;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;}&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/p&gt;
&lt;div&gt;

&lt;p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;/&lt;strong&gt;通过poj 3159 证明：还是用数组来实现邻接表比用链表来实现邻接表效率高，&amp;nbsp; &lt;/strong&gt;/&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;#define MAX_node 10000&amp;nbsp;&lt;/li&gt;&lt;li&gt;#define MAX_edge 100000&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;struct Edge&amp;nbsp; &lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int e, v;&amp;nbsp; &lt;/li&gt;&lt;li&gt;} edge[MAX_edge];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;int neg;&amp;nbsp;&amp;nbsp;&amp;nbsp; //number of edge&amp;nbsp;&lt;/li&gt;&lt;li&gt;int node[MAX_node];&amp;nbsp; //注意node要用memset初始化全部为-1&amp;nbsp;&lt;/li&gt;&lt;li&gt;int next[MAX_edge];&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;void add(int s,int e,int v)&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; edge[neg].e = e;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; edge[neg].v = v;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; next[neg] = node[s];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; node[s] = neg++;&amp;nbsp; &lt;/li&gt;&lt;li&gt;}&amp;nbsp; &lt;/li&gt;&lt;li&gt;/&lt;em&gt;&amp;nbsp; 该题还证明用栈来实现SPFA比用队列来实现效率高，还节约空间 &lt;/em&gt;/&amp;nbsp;&lt;/li&gt;&lt;li&gt;int SPFA(int s0)//栈实现&amp;nbsp;&lt;/li&gt;&lt;li&gt;{&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int i, t, p, top;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; memset(vst, 0, sizeof(vst));&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; for (i=1; i&amp;lt;=n; i++)&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[i] = INF;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; dis[s0] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[0] = s0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; top = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[s0] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; while (top)&amp;nbsp;&lt;br&gt;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; t = Q[–top];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[t] = 0;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; p = node[t];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; while (p != -1)&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (relax(t, edge[p].e, edge[p].v) &amp;amp;&amp;amp; !vst[edge[p].e])&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Q[top++] = edge[p].e;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; vst[edge[p].e] = 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; p = next[p];&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&amp;nbsp; &lt;/li&gt;&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return 1;&amp;nbsp; &lt;/li&gt;&lt;li&gt;} &lt;/li&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;br&gt;&lt;em&gt;如果对我的博文有任何的意见或者建议，欢迎在文章的下方进行评论&lt;/em&gt;&lt;p&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现在是2016年4月21日，今天我学习了不少奇奇怪怪的算法，同时还为我的博客增加了mathJax支持。此文是一篇关于SPFA算法的归纳，部分内容转载，不喜勿喷&lt;br&gt;
    
    </summary>
    
    
      <category term="变强" scheme="http://zhaoleyi.github.io/tags/%E5%8F%98%E5%BC%BA/"/>
    
      <category term="分享" scheme="http://zhaoleyi.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>2016年4月20日总结：堆</title>
    <link href="http://zhaoleyi.github.io/2016/04/20/2016%E5%B9%B44%E6%9C%8820%E6%97%A5%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A0%86/"/>
    <id>http://zhaoleyi.github.io/2016/04/20/2016年4月20日总结：堆/</id>
    <published>2016-04-20T11:59:53.000Z</published>
    <updated>2016-04-21T06:31:20.000Z</updated>
    
    <content type="html">&lt;p&gt;今天是2016年4月20日，然后我看了一下有关于堆的一些奇奇怪怪的东西，为了督促自己认真理解，就写在了文字中，不喜勿喷&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先必须承认一下，堆是一个比较好用的东西，然后比如说优化一下Dijkstra算法，把这个算法的时间复杂度从O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;br&gt;强行压缩到了O((m+n)logn)&lt;/p&gt;
&lt;h1 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，我必须承认一下，在初中的时候王老师已经给我们讲过了，但是由于我当时并没有认真学习，再加上&lt;del&gt;当时大脑发育并不健全&lt;/del&gt;懒&lt;br&gt;于是就这么荒废了，所以到现在，给自己留下来一个个大坑等待填。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，对于堆这个算法来说，排序相对来说是最简单的了，所以，我也是从这个开始学习的。先说一下复杂度：堆排序的时间复杂度无论如何都是&lt;br&gt;O(n log&lt;sub&gt;2&lt;/sub&gt; n)，不需要考虑辅助空间的问题，也就是说，相对的，它最不会被毒瘤数据卡成O(n&lt;sup&gt;2&lt;/sup&gt;)(归并除外)。然后大概的思路就是说首先把读入的&lt;br&gt;数据给建成一个堆，注意，这个过程是首先一个节点一个节点的将元素插到当前数组中最后的一个位置，相当于放在堆底，然后不停的和它的父亲&lt;del&gt;母亲&lt;/del&gt;进行比较交换，直到&lt;br&gt;这个元素被固定下来，然后停止操作，继续插入下一个数。当所有的数都插入完之后，输出的时候先输出堆顶的那个元素，然后从堆底将最后的一个元素给提上来，然后再不停的&lt;br&gt;向下调换，直到该元素被固定，然后重复以上几步。&lt;br&gt;代码君↓(怀念一下写p的青葱岁月)&lt;br&gt;&lt;figure class=&quot;highlight pascal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;program&lt;/span&gt; heap_test;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  heap = &lt;span class=&quot;keyword&quot;&gt;record&lt;/span&gt;                         &lt;span class=&quot;comment&quot;&gt;// small root heap&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    h :&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;100000&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c :longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  h:heap;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  n:longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  t:longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a,b:longint)&lt;/span&gt;;&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;// 交换 a和b&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  t:longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t:=a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a:=b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b:=t;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(pos:longint)&lt;/span&gt;;&lt;/span&gt;               &lt;span class=&quot;comment&quot;&gt;// 向上调整位于 pos的元素 维持堆的特性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (pos&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (h.h[pos]&amp;lt;h.h[pos &lt;span class=&quot;keyword&quot;&gt;shr&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      swap(h.h[pos],h.h[pos &lt;span class=&quot;keyword&quot;&gt;shr&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      pos:=pos &lt;span class=&quot;keyword&quot;&gt;shr&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(pos:longint)&lt;/span&gt;;&lt;/span&gt;               &lt;span class=&quot;comment&quot;&gt;// 向下调整位于 pos的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  i,j:longint;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  i:=pos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;=h.c &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; h.h[i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;gt; h.h[i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;=h.c &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;exit&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (h.h[j] &amp;lt; h.h[i]) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      swap(h.h[i],h.h[j]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      i:=j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;=h.c &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; h.h[i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;gt; h.h[i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;=h.c &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        j:=i &lt;span class=&quot;keyword&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;exit&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x:longint)&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// 将x加入堆&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  inc(h.c);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  h.h[h.c]:=x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  up(h.c);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;del&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(pos:longint)&lt;/span&gt;:&lt;/span&gt;longint;  &lt;span class=&quot;comment&quot;&gt;// 返回 位于 pos的元素值 并将其从堆中删除&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  del:=h.h[pos];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  swap(h.h[pos],h.h[h.c]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dec(h.c);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  down(pos);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  readln(n);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; n:= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; n &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;read&lt;/span&gt;(t);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        add(t);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; h.c&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    writeln(del(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));              &lt;span class=&quot;comment&quot;&gt;// 朴素的堆排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;动态维护数组第k大-小&quot;&gt;&lt;a href=&quot;#动态维护数组第k大-小&quot; class=&quot;headerlink&quot; title=&quot;动态维护数组第k大(小)&quot;&gt;&lt;/a&gt;动态维护数组第k大(小)&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，这个东西显然可以用线段树来搞，但是由于我还没有认真吃透线段树（也许过几天的博文里就会有），&lt;br&gt;所以只能先口胡一下。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最开始的想法是too young too simple的我简简单单的认为只要先排一遍序，然后输出要求的那个就可以了&lt;br&gt;但是转念一想，这样要萎的，因为当数组的元素非常多的时候，一是有可能会T掉，二是有可能会炸数组。然后用堆的做法是要使用一下二叉堆的&lt;br&gt;思路：对于每一个点来说它的左子树中的每一个元素都比它本身要小，它的右子树中的每一个元素都比它本身要大。所以只要&lt;br&gt;维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，&lt;br&gt;将当前值插入到堆中。时间复杂度O(n×logk)，这个算法的最大优势在于，如果数组非常非常大的话，利用普通的排序是爆内存的。&lt;br&gt;用它的话，则只用到K的内存。&lt;/p&gt;
&lt;h1 id=&quot;斜堆-amp-amp-左偏树&quot;&gt;&lt;a href=&quot;#斜堆-amp-amp-左偏树&quot; class=&quot;headerlink&quot; title=&quot;斜堆&amp;amp;&amp;amp;左偏树&quot;&gt;&lt;/a&gt;斜堆&amp;amp;&amp;amp;左偏树&lt;/h1&gt;&lt;p&gt;这两个东西是差不多的，然后我觉得其实这两个东西还是比较好理解的，所以在最后放上这两个小东西&lt;br&gt;一个是斜堆，一个是左偏树。&lt;br&gt;原始的二叉堆使用数组实现，是一个完全二叉树，其实现简单，但是在合并方面不尽人意，只能通过构建一个新的堆来实现两个堆的合并，&lt;br&gt;时间复杂度为O（n）。而左式堆和斜堆是两种合并高效的堆，并且左式堆以及斜堆的insert以及deleteMin等操作都是以merge&lt;br&gt;操作为基础的。merge时间复杂度可以达到O（logn）。&lt;br&gt;左偏树（Leftist Heaps）使用指针实现，它仍然使用二叉树的结构实现，仍满足堆序性，但它不是完全二叉树。相比于二叉树，&lt;br&gt;其节点上增加了一个NPL （null path length）属性，它指的是从该结点到达一个没有两个孩子的结点的最短距离，NULL的NPL为-1。&lt;br&gt;而左式堆的核心约束条件就是：任意结点的左孩子的Npl大于等于右孩子的Npl。&lt;br&gt;我们可以用下面的代码描述左偏树的合并过程：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Function &lt;span class=&quot;title&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(A, B)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	If A = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; Then &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; B&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	If B = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; Then &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; A&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	If key(B) &amp;lt; key(A) Then swap(A, B)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	right(A) ← Merge(right(A), B)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	If dist(right(A)) &amp;gt; dist(left(A)) Then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		swap(left(A), right(A))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	If right(A) = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; Then dist(A) ← &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Else dist(A) ← dist(right(A)) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; A&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;End Function&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后是左偏树的插入过程：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Procedure Insert(x, A)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	B ← MakeIntoTree(x)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	A ← Merge(A, B)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;End Procedure&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删点：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Function DeleteMin(A)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	t ← key(root(A))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	A ← Merge(left(A), right(A))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	return t&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;End Function&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;p&gt;之后会尽量每天更新一篇算法总结，争取在6月份之前成功变强。&lt;br&gt;&lt;em&gt;如果对我的博文有任何的意见或者建议，欢迎在文章的下方进行评论&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2016年4月20日，然后我看了一下有关于堆的一些奇奇怪怪的东西，为了督促自己认真理解，就写在了文字中，不喜勿喷&lt;br&gt;
    
    </summary>
    
    
      <category term="变强" scheme="http://zhaoleyi.github.io/tags/%E5%8F%98%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>变强记录帖</title>
    <link href="http://zhaoleyi.github.io/2016/04/20/%E5%8F%98%E5%BC%BA%E8%AE%B0%E5%BD%95%E5%B8%96/"/>
    <id>http://zhaoleyi.github.io/2016/04/20/变强记录帖/</id>
    <published>2016-04-20T11:50:19.000Z</published>
    <updated>2016-04-20T11:57:14.509Z</updated>
    
    <content type="html">&lt;p&gt;突然发现已经好几天没有写过一道题解了，是时候更新一下博客了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;前几天突然看了一下黄学长的博客中的一篇文章，关于省选前必须掌握的算法，于是心血来潮了一下，把这些算法统统复制到了一个excel表格&lt;br&gt;中，粗略统计一下，除去某些怪七怪八的算法，大概也要有100来种，然后我把自己一定可以打出来的算法给高亮标记了一下，发现少得可怜。&lt;br&gt;所以，为了实现变强&lt;del&gt;买笔记本电脑&lt;/del&gt;的愿望以及&lt;strong&gt;一定要在noip的时候拿到省一等奖&lt;/strong&gt;，于是我决定一个一个算法突破下去，然后这是一个&lt;br&gt;预告贴，之后的除了题解之外，每天还会有一篇对于算法的文章。加油&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;突然发现已经好几天没有写过一道题解了，是时候更新一下博客了&lt;br&gt;
    
    </summary>
    
    
      <category term="变强" scheme="http://zhaoleyi.github.io/tags/%E5%8F%98%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>转：堪称最好的A*算法</title>
    <link href="http://zhaoleyi.github.io/2016/04/14/%E8%BD%AC%EF%BC%9A%E5%A0%AA%E7%A7%B0%E6%9C%80%E5%A5%BD%E7%9A%84A-%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoleyi.github.io/2016/04/14/转：堪称最好的A-算法/</id>
    <published>2016-04-14T00:01:32.000Z</published>
    <updated>2016-04-14T00:07:03.000Z</updated>
    
    <content type="html">&lt;p&gt;首先，这篇文章是转发的，如果我有侵权行为，请给我发邮件或者在文章底下留言，我会在24小时以内删除O(∩_∩)O&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/b2b160/article/details/4057781&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;article_content&quot; class=&quot;article_content&quot;&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;如此好贴，不能不转！原文地址：&lt;a href=&quot;http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;本文版权归原作者、译者所有，我只是转贴；如果侵害到您的权益，请联系我，我将删除本文。&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;基本上，这文章可以说是最佳A&lt;em&gt;算法文档。极力推荐！&lt;/em&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Amit’s A star Page&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;中译文&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;译序&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这篇文章很适合&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法的初学者，可惜&lt;span class=&quot;GramE&quot;&gt;网上没&lt;/span&gt;找到翻译版的。本着好东西不敢独享的想法，也为了锻炼一下英文，本人译了这篇文章。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;由于本人英文水平非常有限，六级考了两次加一块不超过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;370&lt;/span&gt;&lt;span&gt;分，因此本译文难免存在问题。不过也算是抛砖引玉，希望看到有更多的游戏开发方面的优秀译作出现，毕竟中文的优秀资料太少了，中国的游戏开发者的路不好走。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;本人能力有限，译文中有小部分词句实在难以翻译，因此暂时保留英文原文放在译文中。对于不敢确定翻译是否准确的词句，本人用圆括号保留了英文原文，读者可以对照着加以理解。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;算法本身是很简单的，因此原文中并没有过多地讨论&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法本身，而是花了较大的篇幅讨论了用于保存&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集的数据结构，以及&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;算法的变种和扩展。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;编程实现&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;是简单的，读者可以用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;STL&lt;/span&gt;&lt;span&gt;对本文中的伪代码加以实现（本人已花一天时间实验&lt;span class=&quot;GramE&quot;&gt;过基本&lt;/span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;搜索）。但是最重要的还是对&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;本身的理解，这样才可以在自己的游戏中处理各种千变万化的情况。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;翻译本文的想法产生于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2006&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;月，实际完成于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2007&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;月到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span&gt;月，非常惭愧。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;最后，本译文仅&lt;span class=&quot;GramE&quot;&gt;供交流&lt;/span&gt;和参考，对于因本译文放到网上而产生的任何问题，本人不负任何责任。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;right&quot;&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　蔡鸿于南开大学软件学院&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;right&quot;&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;2007&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;年&lt;/span&gt;&lt;/span&gt;6&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;月&lt;/span&gt;&lt;/span&gt;9&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;日&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;原文地址：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://theory.stanford.edu/~amitp/GameProgramming/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theory.stanford.edu/~amitp/GameProgramming/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/%7Eamitp/gameprog.html#Paths&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www-cs-students.stanford.edu/%7Eamitp/gameprog.html#Paths&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我们尝试解决的问题是把一个游戏对象（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;game object&lt;/span&gt;&lt;span&gt;）从出发点移动到目的地。路径搜索&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(Pathfinding)&lt;/span&gt;&lt;span&gt;的目标是找到一条好的路径&amp;mdash;&amp;mdash;避免障碍物、敌人，并把代价（燃料，时间，距离，装备，金钱等）最小化。运动（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Movement&lt;/span&gt;&lt;span&gt;）的目标是找到一条路径并且沿着它行进。把关注的焦点仅集中于其中的一种方法是可能的。一种极端情况是，当游戏对象开始移动时，一个老练的路径搜索器（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;pathfinder&lt;/span&gt;&lt;span&gt;）外加一个琐细的运动算法（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;movement algorithm&lt;/span&gt;&lt;span&gt;）可以找到一条路径，游戏对象将会沿着该路径移动而忽略其它的一切。另一种极端情况是，一个单纯的运动系统（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;movement-only system&lt;/span&gt;&lt;span&gt;）将不会搜索一条路径（最初的&amp;ldquo;路径&amp;rdquo;将被一条直线取代），取而代之的是在每一个结点处仅采取一个步骤，同时考虑周围的环境。同时使用路径搜索&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(Pathfinding)&lt;/span&gt;&lt;span&gt;和运动算法（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;movement algorithm&lt;/span&gt;&lt;span&gt;）将会得到最好的效果。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180937&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;导言&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180938&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1.1&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180939&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1.2&lt;span&gt;&amp;nbsp;Dijkstra&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;算法与最佳优先搜索&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180940&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1.3&lt;span&gt;&amp;nbsp;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180941&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;启发式算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180942&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.1&lt;span&gt;&amp;nbsp;A&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;对启发式函数的使用&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180943&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.2&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;速度还是精确度？&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180944&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.3&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;衡量单位&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180945&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.4&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;精确的启发式函数&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180946&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.4.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;预计算的精确启发式函数&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180947&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.4.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;线性精确启发式算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180948&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;网格地图中的启发式算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180949&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;曼哈顿距离&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180950&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;对角线距离&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180951&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;欧几里得距离&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180952&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;平方后的欧几里得距离&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180953&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.5 Breaking ties&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180954&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2.5.6&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;区域搜索&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180955&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3 Implementation notes&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180956&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;概略&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180957&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;源代码&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180958&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;集合的表示&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180959&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;未排序数组或链表&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180960&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;排序数组&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180961&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;排序链表&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180962&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;排序跳表&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180963&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.5&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;索引数组&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180964&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.6&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;哈希表&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180965&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.7&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;二元堆&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180966&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.8&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;伸展树&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180967&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.9 HOT&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;队列&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180968&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.10&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;比较&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180969&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.3.11&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;混合实现&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180970&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;与游戏循环的交互&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180971&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.4.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;提前退出&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180972&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.4.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;中断算法&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180973&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.4.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;组运动&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180974&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3.4.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;细化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180975&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4 A&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;算法的变种&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180976&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.1 beam search&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180977&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;迭代深化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180978&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;动态衡量&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180979&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;带宽搜索&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180980&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.5&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;双向搜索&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180981&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4.6&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;动态&lt;/span&gt;&lt;/span&gt;A&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;与终身计划&lt;/span&gt;&lt;/span&gt;A&lt;em&gt;&lt;/em&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180982&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;处理运动障碍物&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180983&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;重新计算路径&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180984&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;路径拼接&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180985&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;监视地图变化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180986&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;预测障碍物的运动&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180987&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;预计算路径的空间代价&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180988&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;位置&lt;/span&gt;&lt;/span&gt;VS&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;方向&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180989&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;路径压缩&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.2.1&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;位置存储&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc3&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180991&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.2.2&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;方向存储&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180992&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.3&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;计算导航点&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180993&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.4&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;极限路径长度&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoToc2&quot;&gt;&lt;span class=&quot;MsoHyperlink&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht#_Toc169180994&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;6.5&amp;nbsp;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;a name=&quot;_Toc169180937&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;导言&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;移动一个简单的物体（&lt;span lang=&quot;EN&quot;&gt;object&lt;/span&gt;）看起来是容易的。而路径搜索是复杂的。为什么涉及到路径搜索就产生麻烦了？考虑以下情况：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/GameProgramming/concave1.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;物体（&lt;span lang=&quot;EN&quot;&gt;unit&lt;/span&gt;）最初位于地图的底端并且尝试向顶部移动。物体扫描的区域中&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;粉红色部分&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;没有任何东西显示它不能向上移动，因此它持续向上移动。在靠近顶部时，它探测到一个障碍物然后改变移动方向。然后它沿着&lt;span lang=&quot;EN&quot;&gt;U&lt;/span&gt;形障碍物找到它的红色的路径。相反的，一个路径搜索器（&lt;span lang=&quot;EN&quot;&gt;pathfinder&lt;/span&gt;）将会扫描一个更大的区域（淡蓝色部分），但是它能做到不让物体&lt;span lang=&quot;EN&quot;&gt;(unit)&lt;/span&gt;走向凹形障碍物而找到一条更短的路径&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;蓝色路径）。&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　然而你可以扩展一个运动算法，用于对付上图所示的障碍物。或者避免制造凹形障碍，或者把凹形出口标识为危险的&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;只有当目的地在里面时才进去&lt;span lang=&quot;EN&quot;&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/GameProgramming/concave2.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　比起一直等到最后一刻才发现问题，路径搜索器让你提前&lt;span class=&quot;GramE&quot;&gt;作出&lt;/span&gt;计划。不带路径搜索的运动&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(movement)&lt;/span&gt;&lt;span&gt;可以在很多种情形下工作，同时可以扩展到更多的情形，但是路径搜索是一种更常用的解决更多问题的方法。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180938&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　计算机科学教材中的路径搜索算法在数学视角的图上工作&amp;mdash;&amp;mdash;由边联结起来的结点的集合。一个&lt;span class=&quot;GramE&quot;&gt;基于图块&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(tile)&lt;/span&gt;&lt;span&gt;拼接的游戏地图可以看成是一个图，&lt;span class=&quot;GramE&quot;&gt;每个图块&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(tile)&lt;/span&gt;&lt;span&gt;是一个结点，并在&lt;span class=&quot;GramE&quot;&gt;每个图块之间&lt;/span&gt;画一条边：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/map-as-graph.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　目前，我会假设我们使用二维网格&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(grid)&lt;/span&gt;&lt;span&gt;。稍后我将讨论如何在你的游戏之外建立其他类型的图。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span&gt;　　许多&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;AI&lt;/span&gt;&lt;span&gt;领域或算法研究领域中的路径搜索算法是基于任意&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(arbitrary)&lt;/span&gt;&lt;span&gt;的图设计的，而不是基于网格&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(grid-based)&lt;/span&gt;&lt;span&gt;的图。我们可以找到一些能使用网格地图的特性的东西。有一些我们认为是常识，而算法并不理解。例如，我们知道一些和方向有关的东西：一般而言，如果两个物体距离越远，那么把其中一个物体向另一个移动将花越多的时间；并且我们知道地图中没有任何秘密通道可以从一个地点通向另一个地点。（我假设没有，如果有的话，将会很难找到一条好的路径，因为你并不知道要从何处开始。）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180939&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.2&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;Dijkstra&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;算法与最佳优先搜索&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;　　&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;算法从物体所在的初始点开始，访问图中的结点。它迭代检查待检查结点集中的结点，并把和该结点最靠近的尚未检查的结点加入待检查结点集。该结点集从初始结点向外扩展，直到到达目标结点。&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;算法保证能找到一条从初始点到目标点的最短路径，只要所有的边都有一个非负的代价值。（我说&amp;ldquo;最短路径&amp;rdquo;是因为经常会出现许多差不多短的路径。）在下图中，粉红色的结点是初始结点，蓝色的是目标点，而类菱形的有色区域（注：原文是&lt;span lang=&quot;EN&quot;&gt;teal areas&lt;/span&gt;）则是&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;算法扫描过的区域。颜色最淡的区域是那些离初始点最远的，因而形成探测过程（&lt;span lang=&quot;EN&quot;&gt;exploration&lt;/span&gt;）的边境（&lt;span lang=&quot;EN&quot;&gt;frontier&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/dijkstra.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;　　最佳优先搜索（&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;）算法按照类似的流程运行，不同的是它能够评估（称为启发式的）任意结点到目标点的代价。与选择离初始结点最近的结点不同的是，它选择离目标最近的结点。&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;不能保证找到一条最短路径。然而，它比&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;算法快的多，因为它用了一个启发式函数（&lt;span lang=&quot;EN&quot;&gt;heuristic function&lt;/span&gt;）快速地导向目标结点。例如，如果目标位于出发点的南方，&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;将趋向于导向南方的路径。在下面的图中，越黄的结点代表越高的启发式值（移动到目标的代价高），而越黑的结点代表越低的启发式值（移动到目标的代价低）。这表明了与&lt;span lang=&quot;EN&quot;&gt;Dijkstra&amp;nbsp;&lt;/span&gt;算法相比，&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;运行得更快。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/best-first-search.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;　　然而，这两个例子都仅仅是最简单的情况&amp;mdash;&amp;mdash;地图中没有障碍物，最短路径是直线的。现在我们来考虑前边描述的凹型障碍物。&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;算法运行得较慢，但确实能保证找到一条最短路径：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/dijkstra-trap.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　另一方面，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;运行得较快，但是它找到的路径明显不是一条好的路径：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/best-first-search-trap.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;　　问题在于&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;是基于贪心策略的，它试图向目标移动尽管这不是正确的路径。由于它仅仅考虑到达目标的代价，而忽略了当前已花费的代价，于是尽管路径变得很长，它仍然继续走下去。&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;span&gt;　　结合两者的优点不是更好吗？&lt;span lang=&quot;EN&quot;&gt;1968&lt;/span&gt;年发明的&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;算法就是把启发式方法（&lt;span lang=&quot;EN&quot;&gt;heuristic approaches&lt;/span&gt;）如&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;，和常规方法如&lt;span lang=&quot;EN&quot;&gt;Dijsktra&lt;/span&gt;算法结合在一起的算法。有点不同的是，类似&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;的启发式方法经常给出一个近似解而不是保证最佳解。然而，尽管&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;基于无法保证&lt;span class=&quot;GramE&quot;&gt;最佳解&lt;/span&gt;的启发式方法，&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;却能保证找到一条最短路径。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180940&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.3&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　我将集中讨论&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;是路径搜索中最受欢迎的选择，因为它相当灵活，并且能用于多种多样的情形之中。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　和其它的图搜索算法一样，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;潜在地搜索图中一个很大的区域。和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;一样，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;能用于搜索最短路径。和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;一样，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;能用启发式函数（注：原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;heuristic&lt;/span&gt;&lt;span&gt;）引导它自己。在简单的情况中，它和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;一样快。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/a-star.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　在凹型障碍物的例子中，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;找到一条和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;算法一样好的路径：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/a-star-trap.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　成功的&lt;span class=&quot;GramE&quot;&gt;秘决&lt;/span&gt;在于，它把&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;算法（靠近初始点的结点）和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;算法（靠近目标点的结点）的信息&lt;span class=&quot;GramE&quot;&gt;块结合&lt;/span&gt;起来。在讨论&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的标准术语中，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;表示从初始结点到任意结点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;的代价，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;表示从结点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;到目标点的启发式评估代价（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;heuristic estimated cost&lt;/span&gt;&lt;span&gt;）。在上图中，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;yellow(h)&lt;/span&gt;&lt;span&gt;表示远离目标的结点而&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;teal(g)&lt;/span&gt;&lt;span&gt;表示远离初始点的结点。当从初始点向目标点移动时，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;权衡这两者。每次进行主循环时，它检查&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n)&lt;/span&gt;&lt;span&gt;最小的结点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n) = g(n) + h(n)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;a name=&quot;_Toc169180941&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;启发式算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　启发式函数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;告诉&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;从任意结点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;到目标结点的最小代价评估值。选择一个好的启发式函数是重要的。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180942&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;对启发式函数的使用&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　启发式函数可以控制&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的行为：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一种极端情况，如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;&lt;span&gt;，则只有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;起作用，此时&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;演变成&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;算法，这保证能找到最短路径。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;经常都比从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;移动到目标的实际代价小（或者相等），则&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;保证能找到一条最短路径。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;越小，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;扩展的结点越多，运行就得越慢。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;精确地等于从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;移动到目标的代价，则&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;将会仅仅寻找最佳路径而不扩展别的任何结点，这会运行得非常快。尽管这不可能在所有情况下发生，你仍可以在一些特殊情况下让它们精确地相等（译者：指让&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;精确地等于实际值）。只要提供完美的信息，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;会运行得很完美，认识这一点很好。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;有时比从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;移动到目标的实际代价高，则&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;不能保证找到一条最短路径，但它运行得更快。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另一种极端情况，如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;比&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;大很多，则只有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;起作用，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;演变成&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;算法。&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　所以我们得到一个很有趣的情况，那就是我们可以决定我们想要从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;中获得什么。理想情况下（注：原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;At exactly the right point&lt;/span&gt;&lt;span&gt;），我们想最快地得到最短路径。如果我们的目标太低，我们仍会得到最短路径，不过速度变慢了；如果我们的目标太高，那我们就放弃了最短路径，但&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;运行得更快。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在游戏中，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的这个特性非常有用。例如，你会发现在某些情况下，你希望得到一条好的路径（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“good” path&lt;/span&gt;&lt;span&gt;）而不是一条完美的路径（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“perfect” path&lt;/span&gt;&lt;span&gt;）。为了权衡&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;，你可以修改任意一个。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;注&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在学术上，如果启发式函数值是对实际代价的低估，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;算法被称为简单的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法（原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;simply A&lt;/span&gt;&lt;span&gt;）。然而，我继续称之为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;，因为在实现上是一样的，并且在游戏编程领域并不区别&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180943&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.2&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;速度还是精确度？&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;改变它自己行为的能力基于启发式代价函数，启发式函数在游戏中非常有用。在速度和精确度之间取得折衷将会让你的游戏运行得更快。在很多游戏中，你并不真正需要得到最好的路径，仅需要近似的就足够了。而你需要什么则取决于游戏中发生着什么，或者运行游戏的机器有多快。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　假设你的游戏有两种地形，平原和山地，在平原中的移动代价是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;而在山地则是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt; is going to search three times as far along flat land as it does along mountainous land.&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;这是因为有可能有一条沿着平原到山地的路径。把两个邻接点之间的评估距离设为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.5&lt;/span&gt;&lt;span&gt;可以加速&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的搜索过程。然后&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;会将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.5&lt;/span&gt;&lt;span&gt;比较，这并&lt;span class=&quot;GramE&quot;&gt;不比把&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;比较差。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;It is not as dissatisfied with mountainous terrain, so it won’t spend as much time trying to find a way around it. Alternatively, you can speed up up A‘s search by decreasing the amount it searches for paths around mountains―just tell A&lt;em&gt; that the movement cost on mountains is 2 instead of 3. Now it will search only twice as far along the flat terrain as along mountainous terrain. Either approach gives up ideal paths to get something quicker.&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;速度和精确度之间的选择前不是静态的。你可以基于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;的速度、用于路径搜索的时间片数、地图上物体（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;units&lt;/span&gt;&lt;span&gt;）的数量、物体的重要性、组（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;group&lt;/span&gt;&lt;span&gt;）的大小、难度或者其他任何因素来进行动态的选择。取得动态的折衷的一个方法是，建立一个启发式函数用于假定通过一个网格空间的最小代价是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;，然后建立一个代价函数（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cost function&lt;/span&gt;&lt;span&gt;）用于测量（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;scales&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;rsquo;(n) = 1 + alpha  ( g(n) &amp;ndash; 1&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;alpha&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;&lt;span&gt;，则改进后的代价函数的值总是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;。这种情况下，地形代价被完全忽略，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;工作变成简单地判断一个网格可否通过。如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;alpha&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;，则最初的代价函数将起作用，然后你得到了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的所有优点。你可以设置&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;alpha&lt;/span&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的任意值。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　你也可以考虑对启发式函数的返回值做选择：绝对最小代价或者期望最小代价。例如，如果你的地图大部分地形是代价为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;的草地，其它一些地方是代价为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的道路，那么你可以考虑让启发式函数不考虑道路，而只返回&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;距离。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　速度和精确度之间的选择并不是全局的。在地图上的某些区域，精确度是重要的，你可以基于此进行动态选择。例如，假设我们可能在某点停止重新计算路径或者改变方向，则在接近当前位置的地方，选择一条好的路径则是更重要的，因此为何要对后续路径的精确度感到厌烦？或者，对于在地图上的一个安全区域，最短路径也许并不十分重要，但是当从一个敌人的村庄逃跑时，安全和速度是最重要的。（译者注：译者认为这里指的是，在安全区域，可以考虑不寻找精确的最短路径而取近似路径，因此寻路快；但在危险区域，逃跑的安全性和逃跑速度是重要的，即路径的精确度是重要的，因此可以多花点时间用于寻找精确路径。）&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180944&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.3&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;衡量单位&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n) = g(n) + h(n)&lt;/span&gt;&lt;span&gt;。为了对这两个值进行相加，这两个&lt;span class=&quot;GramE&quot;&gt;值必须&lt;/span&gt;使用相同的衡量单位。如果&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;用小时来衡量而&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;用米来衡量，那么&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;将会认为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h&lt;/span&gt;&lt;span&gt;太大或者太小，因而你将不能得到正确的路径，同时你的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法将运行得更慢。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180945&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.4&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;精确的启发式函数&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果你的启发式函数精确地等于实际最佳路径（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;optimal path&lt;/span&gt;&lt;span&gt;），如下一部分的图中所示，你会看到此时&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;扩展的结点将非常少。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法内部发生的事情是：在每一结点它都计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n) = g(n) + h(n)&lt;/span&gt;&lt;span&gt;。当&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;精确地和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;匹配（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;match&lt;/span&gt;&lt;span&gt;）时，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n)&lt;/span&gt;&lt;span&gt;的值在沿着该路径时将不会改变。不在正确路径（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;right path&lt;/span&gt;&lt;span&gt;）上的所有结点的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;值均大于正确路径上的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;值（译者注：正确路径在这里应该是指最短路径）。如果已经有较低&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;值的结点，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;将不考虑&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;值较高的结点，因此它肯定不会偏离最短路径。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180946&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.4.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;预计算的精确启发式函数&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　构造精确启发函数的一种方法是预先计算任意一对结点之间最短路径的长度。在许多游戏的地图中这并不可行。然后，有几种方法可以近似模拟这种启发函数：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Fit a coarse grid on top of the fine grid. Precompute the shortest path between any pair of coarse grid locations.&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Precompute the shortest path between any pair of&amp;nbsp;&lt;a href=&quot;http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;waypoints&lt;/span&gt;&lt;/a&gt;. This is a generalization of the coarse grid approach.&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（译者：此处不好翻译，暂时保留原文）&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;然后添加一个启发函数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;用于评估从任意位置到达邻近导航点（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;waypoints&lt;/span&gt;&lt;span&gt;）的代价。（如果愿意，后者也可以通过预计算得到。）最终的启发式函数可以是：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n) = h’(n, w1) + distance(w1, w2), h’(w2, goal)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;或者如果你希望一个更好但是更昂贵的启发式函数，则分别用靠近结点和目标的所有的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;w1,w2&lt;/span&gt;&lt;span&gt;对对上式进行求值。（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;or if you want a better but more expensive heuristic, evaluate the above with all pairs w1, w2 that are close to the node and the goal, respectively.&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180947&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.4.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;线性精确启发式算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　在特殊情况下，你可以不通过预计算而让启发式函数很精确。如果你有一个不存在障碍物和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;slow&lt;/span&gt;&lt;span&gt;地形，那么从初始点到目标的最短路径应该是一条直线。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果你正使用简单的启发式函数（我们不知道地图上的障碍物），则它应该和精确的启发式函数相符合（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;match&lt;/span&gt;&lt;span&gt;）。如果不是这样，则你会遇到衡量单位的问题，或者你所选择的启发函数类型的问题。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180948&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;网格地图中的启发式算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　在网格地图中，有一些众所周知的启发式函数。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180949&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;曼哈顿距离&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;标准的启发式函数是曼哈顿距离（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Manhattan distance&lt;/span&gt;&lt;span&gt;）。考虑你的代价函数并找到从一个位置移动到邻近位置的最小代价&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;D&lt;/span&gt;&lt;span&gt;。因此，我的游戏中的启发式函数应该是曼哈顿距离的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;倍&lt;/span&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;H(&lt;/span&gt;n) = D  (abs ( n.x &amp;ndash; goal.x ) + abs ( n.y &amp;ndash; goal.y ) )&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;你应该使用符合你的代价函数的衡量单位。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/manhattan.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;(Note: the above image has a&amp;nbsp;&lt;a href=&quot;http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S12&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;tie-breaker&lt;/span&gt;&lt;/a&gt;&amp;nbsp;added to the heuristic.}&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;（译者注：曼哈顿距离&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;mdash;&amp;mdash;&lt;/span&gt;&lt;span&gt;两点在南北方向上的距离加上在东西方向上的距离，即&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;I&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;J&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;=|XI-XJ|+|YI-YJ|&lt;/span&gt;&lt;span&gt;。对于一个具有正南正北、正东正西方向规则布局的城镇街道，从一点到达另一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离因此曼哈顿距离又称为出租车距离，曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;mdash;&amp;mdash;&lt;/span&gt;&lt;span&gt;百度知道）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180950&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;对角线距离&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果在你的地图中你允许对角运动那么你需要一个不同的启发函数。（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;4 east, 4 north&lt;/span&gt;&lt;span&gt;）的&lt;/span&gt;&lt;span&gt;曼哈顿距离将变成&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;8&lt;em&gt;D&lt;/em&gt;&lt;/span&gt;&lt;span&gt;。然而，你可以简单地移动（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4 northeast&lt;/span&gt;&lt;span&gt;）代替，所以启发函数应该是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4D&lt;/span&gt;&lt;span&gt;。这个函数使用对角线，假设直线和对角线的代价都是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;D&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n) = D &lt;em&gt; max(abs(n.x - goal.x), abs(n.y - goal.y))&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/diagonal.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果对角线运动的代价不是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;，但类似于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D2 = sqrt(2)  D&lt;/span&gt;&lt;span&gt;，则上面的启发函数不准确。你需要一些更准确（原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;sophisticated&lt;/span&gt;&lt;span&gt;）的东西：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;em&gt;&lt;span class=&quot;GramE&quot;&gt;diagonal(&lt;/span&gt;n) = min(abs(n.x - goal.x), abs(n.y - goal.y))&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;span class=&quot;GramE&quot;&gt;straight(&lt;/span&gt;n) = (abs(n.x - goal.x) + abs(n.y - goal.y))&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n) = D2 &lt;em&gt; h_diagonal(n) + D &lt;/em&gt; (h_straight(n) - 2&lt;em&gt;h_diagonal(n)))&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这里，我们计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h_diagonal(n)&lt;/span&gt;&lt;span&gt;：沿着斜线可以移动的步数；&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h_straight(n)&lt;/span&gt;&lt;span&gt;：曼哈顿距离；然后合并这两项，让所有的斜线步都乘以&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;D2&lt;/span&gt;&lt;span&gt;，剩下的所有直线步&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;&lt;span&gt;注意这里是曼哈顿距离的步数减去&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;倍的斜线步数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;都乘以&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;D&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180951&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;欧几里得距离&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果你的单位可以沿着任意角度移动（而不是网格方向），那么你也许应该使用直线距离：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n) = D  sqrt((n.x-goal.x)^2 + (n.y-goal.y)^2)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;然而，如果是这样的话，直接使用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;时将会遇到麻烦，因为代价函数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g&lt;/span&gt;&lt;span&gt;不会&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;match&lt;/span&gt;&lt;span&gt;启发函数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;/span&gt;&lt;span&gt;。因为欧几里&lt;span class=&quot;GramE&quot;&gt;得距离&lt;/span&gt;比曼哈顿距离和对角线距离都短，你仍可以得到最短路径，不过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;将运行得更久一些：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/euclidean.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180952&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;平方后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的欧几里得距离&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我曾经看到一些&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的网页，其中提到让你通过使用距离的平方而避免欧几里&lt;span class=&quot;GramE&quot;&gt;得距离&lt;/span&gt;中昂贵的平方根运算：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;h(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n) = D  ((n.x-goal.x)^2 + (n.y-goal.y)^2)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;不要这样做！这明显地导致衡量单位的问题。当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f(n) = g(n) + h(n)&lt;/span&gt;&lt;span&gt;，距离的&lt;span class=&quot;GramE&quot;&gt;平方将&lt;/span&gt;比&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g&lt;/span&gt;&lt;span&gt;的代价大很多，并且你会因为启发式函数评估值过高而停止。对于更长的距离，这样做会靠近&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g(n)&lt;/span&gt;&lt;span&gt;的极端情况而不再计算任何东西，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;退化成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;BFS&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/best-first-search-trap.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180953&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.5 Breaking ties&lt;/span&gt;&lt;/a&gt;&amp;nbsp;&lt;span style=&quot;font-size: small;&quot;&gt;Breaking ties&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;导致低性能的一个原因来自于启发函数的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;ties&lt;/span&gt;&lt;span&gt;（注：这个词实在不知道应该翻译为什么）。当某些路径具有相同的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值的时候，它们都会被搜索（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;explored&lt;/span&gt;&lt;span&gt;），尽管我们只需要搜索其中的一条：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/tie-breaking-off.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Ties in f values.&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为了解决这个问题，我们可以为启发函数添加一个附加值（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;small tie breaker&lt;/span&gt;&lt;span&gt;）。附加值对于结点必须是确定性的（也就是说，不能是随机的数），而且它必须让&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;值体现&lt;/span&gt;&lt;/span&gt;&lt;span&gt;区别。因为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值排序，让&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值不同意味着只有一个&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;“equivalent”&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值会被检测。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一种添加附加值的方式是稍微改变（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;nudge&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;/span&gt;&lt;span&gt;的衡量单位。如果我们减少衡量单位（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;scale it downwards&lt;/span&gt;&lt;span&gt;），那么当我们朝着目标移动的时候&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;将逐渐增加。很不幸，这意味着&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。我们可以增加衡量单位（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;scale it downwards scale h upwards slightly&lt;/span&gt;&lt;span&gt;）（甚至是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;0.1%&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;就会倾向于扩展到靠近目标的结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;heuristic&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;= (1.0 + p)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;选择因子&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p&lt;/span&gt;&lt;span&gt;使得&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p &amp;lt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;移动一步（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;step&lt;/span&gt;&lt;span&gt;）的最小代价&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;/&amp;nbsp;&lt;/span&gt;&lt;span&gt;期望的最长路径长度。假设你不希望你的路径超过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1000&lt;/span&gt;&lt;span&gt;步（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;step&lt;/span&gt;&lt;span&gt;），你可以使&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p = 1 / 1000&lt;/span&gt;&lt;span&gt;。添加这个附加值的结果是，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;比以前搜索的结点更少了。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/tie-breaking-scale-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;Tie-breaking scaling added to heuristic.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当存在障碍物时，当然仍要在它们周围寻找路径，但要意识到，当绕过障碍物以后，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;搜索的区域非常少：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/tie-breaking-scale-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;Tie-breaking scaling added to heuristic, works nicely with obstacles.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Steven van Dijk&lt;/span&gt;&lt;span&gt;建议，一个更直截了当的方法是把&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;/span&gt;&lt;span&gt;传递到比较函数（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;comparison function&lt;/span&gt;&lt;span&gt;）。当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值相等时，比较函数检查&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;/span&gt;&lt;span&gt;，然后添加附加值。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一个不同的添加附加值的方法是，倾向于从初始点到目标点的连线（直线）：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;dx1 = current.x - goal.x&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;dy1 = current.y - goal.y&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;dx2 = start.x - goal.x&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;dy2 = start.y - goal.y&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;cross&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;= abs(dx1&lt;em&gt;dy2 - dx2&lt;/em&gt;dy1)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;heuristic&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;+= cross&lt;em&gt;0.001&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这段代码计算初始&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;-&lt;/span&gt;&lt;span&gt;目标向量（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;start to goal vector&lt;/span&gt;&lt;span&gt;）和当前&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;-&lt;/span&gt;&lt;span&gt;目标向量（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;current point to goal vector&lt;/span&gt;&lt;span&gt;）的向量叉积（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;vector cross-product&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;When these vectors don’t line up, the cross product will be larger.&lt;/span&gt;&lt;span&gt;结果是，这段代码选择的路径稍微倾向于从初始点到目标点的直线。当没有障碍物时，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;不仅搜索很少的区域，而且它找到的路径看起来&lt;span class=&quot;GramE&quot;&gt;非常&lt;/span&gt;棒：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/tie-breaking-cross-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;Tie-breaking cross-product added to heuristic, produces pretty paths.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;然而，因为这种附加值倾向于从初始点到目标点的直线路径，当出现障碍物时将会出现奇怪的结果（注意这条路径仍是最佳的，只是看起来很奇怪）：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/game-programming/a-star/tie-breaking-cross-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;Tie-breaking cross-product added to heuristic, less pretty with obstacles.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为了交互地研究这种附加值方法的改进，请参考&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;James Macgill&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;确&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;applet&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.ccg.leeds.ac.uk/james/aStar/&amp;amp;nbsp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ccg.leeds.ac.uk/james/aStar/&amp;amp;nbsp&lt;/a&gt;;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;[&lt;/span&gt;&lt;span&gt;如果链接无效，请使用这个镜像（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.vision.ee.ethz.ch/~buc/astar/AStar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.vision.ee.ethz.ch/~buc/astar/AStar.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;]&lt;/span&gt;&lt;span&gt;（译者注：两个&lt;span class=&quot;GramE&quot;&gt;链接均&lt;/span&gt;无效）。使用&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Clear&lt;/span&gt;&lt;span&gt;&amp;rdquo;以清除地图，选择地图对角的两个点。当你使用&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Classic A&lt;/span&gt;&lt;span&gt;&amp;rdquo;方法，你会看到附加值的效果。当你使用&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Fudge&lt;/span&gt;&lt;span&gt;&amp;rdquo;方法，你会看到上面给启发函数添加&lt;span class=&quot;GramE&quot;&gt;叉积后&lt;/span&gt;的效果。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;然而另一种添加附加值的方法是，小心地构造你的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;优先队列，使新插入的具有特殊&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值的结点总是比那些以前插入的具有相同&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值的旧结点要好一些。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;你也许也想看看能够更灵活地（译者注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;sophisticated&lt;/span&gt;&lt;span&gt;）添加附加值的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;AlphA&lt;/span&gt;&lt;span&gt;算法（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://home1.stofanet.dk/breese/papers.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://home1.stofanet.dk/breese/papers.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;），不过用这种算法得到的路径是否能达到最佳仍在研究中。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;AlphA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;具有较好的适应性，而且可能比我在上面讨论的附加值方法运行得都要好。然而，我所讨论的附加值方法非常容易实现，所以从它们开始吧，如果你需要得到更好的效果，再去尝试&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;AlphA&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180954&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5.6&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;区域搜索&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果你想搜索&lt;/span&gt;&lt;span&gt;邻&lt;/span&gt;&lt;span&gt;近目标的任意不确定结点，而不是某个特定的结点，你应该建立一个启发函数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;(x)&lt;/span&gt;&lt;span&gt;，使得&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;(x)&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h1(x), h2(x), h3(x)&lt;/span&gt;&lt;span&gt;。。。的最小值，而这些&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h1, h2, h3&lt;/span&gt;&lt;span&gt;是邻近结点的启发函数。然而，一种更快的方法是让&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;仅搜索目标区域的中心。一旦你从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集合中取得任意一个邻近目标的结点，你就可以停止搜索并建立一条路径了。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;a name=&quot;_Toc169180955&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3 Implementation notes&lt;/span&gt;&lt;/a&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180956&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;概略&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果不考虑具体实现代码，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法是相当简单的。有两个集合，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集。其中&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集保存待考查的结点。开始时，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;集只包含&lt;/span&gt;&lt;/span&gt;&lt;span&gt;一个元素：初始结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集保存已考查过的结点。开始时，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集是空的。如果绘成图，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集就是被访问区域的边境（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;frontier&lt;/span&gt;&lt;span&gt;）而&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集则是被访问区域的内部（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;interior&lt;/span&gt;&lt;span&gt;）。每个结点同时保存其父结点的指针因此我们可以知道它是如何被找到的。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　在主循环中重复地从&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中取出最好的结点&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值最小的结点）并检查之。如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;是目标结点，则我们的任务完成了。否则，结点&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;被从&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中删除并加入&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集。然后检查它的邻居&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。如果邻居&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集中，那么它是已经被检查过的，所以我们不需要考虑它&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;；如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中，那么它是以后肯定会被检查的，所以我们现在不考虑它&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;span&gt;。否则，把它加入&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集，把它的父结点设为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;。到达&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的路径的代价&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g(n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;，设定为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g(n) + movementcost(n, n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;em&gt;)&lt;/em&gt;&lt;/span&gt;&lt;span&gt;这里我忽略了一个小细节。你确实需要检查结点的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g&lt;/span&gt;&lt;span&gt;值是否更小了，如果是的话，需要重新打开（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;re-open&lt;/span&gt;&lt;span&gt;）它。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN = priority queue containing START&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED = empty set&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;while&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;lowest rank in OPEN is not the GOAL:&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;current&lt;/span&gt;&amp;nbsp;= remove lowest rank item from OPEN&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;add&lt;/span&gt;&amp;nbsp;current to CLOSED&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;for&lt;/span&gt;&amp;nbsp;neighbors of current:&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;cost&lt;/span&gt;&amp;nbsp;= g(current) + movementcost(current, neighbor)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;if&lt;/span&gt;&amp;nbsp;neighbor in OPEN and cost less than g(neighbor):&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;remove&lt;/span&gt;&amp;nbsp;neighbor from OPEN, because new path is better&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;if&lt;/span&gt;&amp;nbsp;neighbor in CLOSED and cost less than g(neighbor): &lt;strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;remove&lt;/span&gt;&amp;nbsp;neighbor from CLOSED&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;if&lt;/span&gt;&amp;nbsp;neighbor not in OPEN and neighbor not in CLOSED:&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;set&lt;/span&gt;&amp;nbsp;g(neighbor) to cost&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;add&lt;/span&gt;&amp;nbsp;neighbor to OPEN&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;set&lt;/span&gt;&amp;nbsp;priority queue rank to g(neighbor) + h(neighbor)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;set&lt;/span&gt;&amp;nbsp;neighbor’s parent to current&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;reconstruct&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;reverse path from goal to start&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;by&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;following parent pointers&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;() This should never happen if you have an admissible heuristic. However in games we often have inadmissible heuristics.&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180957&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;源代码&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我自己的（旧的）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C++A&lt;/span&gt;&lt;span&gt;代码是可用的：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;path.cpp (&lt;a href=&quot;http://theory.stanford.edu/~amitp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theory.stanford.edu/~amitp/&lt;/a&gt; GameProgramming/path.cpp)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;path.h (&lt;a href=&quot;http://theory.stanford.edu/~amitp/GameProgramming/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theory.stanford.edu/~amitp/GameProgramming/&lt;/a&gt; path.h)&lt;/span&gt;&lt;span&gt;，但是不容易阅读。还有一份更老的代码（更慢的，但是更容易理解），和很多其它的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;实现一样，它在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Steve Woodcock’&lt;/span&gt;&lt;span&gt;的游戏&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;AI&lt;/span&gt;&lt;span&gt;页面（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.gameai.com/ai.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;http://www.gameai.com/ai.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在网上，你能找到&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C++&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Visual Basic&amp;nbsp;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Java(&lt;a href=&quot;http://www.cuspy.com/software/pathfinder/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cuspy.com/software/pathfinder/&lt;/a&gt; doc/)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Flash/Director/Lingo,&amp;nbsp;&lt;a href=&quot;http://www.codeproject.com/csharp/CSharpPathfind.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;C#&lt;/span&gt;&lt;/a&gt;(&lt;a href=&quot;http://www.codeproject.com/csharp/CSharpPathfind.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;http://www.codeproject.com/csharp/CSharpPathfind.asp&lt;/span&gt;&lt;/a&gt;), Delphi, Lisp, Python, Perl,&amp;nbsp;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/5_1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;Prolog&lt;/span&gt;&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;实现的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;代码。一定的阅读&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Justin Heyes-Jones&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C++&lt;/span&gt;&lt;span&gt;实现（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.geocities.com/jheyesjones/astar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;http://www.geocities.com/jheyesjones/astar.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180958&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;集合的表示&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;你首先想到的用于实现&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集的数据结构是什么？如果你和我一样，你可能想到&amp;ldquo;数组&amp;rdquo;。你也可能想到&amp;ldquo;链表&amp;rdquo;。我们可以使用很多种不同的数据结构，为了选择一种，我们应该考虑我们需要什么样的操作。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集上我们主要有三种操作：主循环重复选择最好的结点并删除它；访问邻居结点时需要检查它是否在集合里面；访问邻居结点时需要插入新结点。插入和删除&lt;span class=&quot;GramE&quot;&gt;最佳是&lt;/span&gt;优先队列（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://members.xoom.com/killough/heaps.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://members.xoom.com/killough/heaps.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）的典型操作。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;选择哪种数据结构不仅取决于操作，还取决于每种操作执行的次数。检查一个结点是否在集合中这一操作对每个被访问的结点的每个邻居结点都执行一次。删除最佳操作对每个被访问的结点都执行一次。被考虑到的绝大多数结点都会被访问；不被访问的是搜索空间边缘（&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;fringe&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）的结点。当评估数据结构上面的这些操作时，必须考虑&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;fringe(F)&lt;/span&gt;&lt;span&gt;的最大值。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另外，还有第四种操作，虽然执行的次数相对很少，但还是必须实现的。如果正被检查的结点已经在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中（这经常发生），并且如果它的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值比已经在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的结点要好（这很少见），那么&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的&lt;span class=&quot;GramE&quot;&gt;值必须&lt;/span&gt;被调整。调整操作包括删除结点（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值不是最佳的结点）和重插入。这两个步骤必须被最优化为一个步骤，这个步骤将移动结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180959&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;未排序数组或链表&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;最简单的数据结构是未排序数组或链表。集合关系检查操作（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Membership test&lt;/span&gt;&lt;span&gt;）很慢，扫描整个结构花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。插入操作很快，添加到末尾花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。查找最佳元素（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Finding the best element&lt;/span&gt;&lt;span&gt;）很慢，扫描整个结构花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。对于数组，删除最佳元素（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Removing the best element&lt;/span&gt;&lt;span&gt;）花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;，而链表则是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。调整操作中，查找结点花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;，改变值花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180960&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;排序数组&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为了加快删除最挂操作，可以对数组进行排序。集合关系检查操作将变成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;，因为我们可以使用折半查找。插入操作会很慢，为了给新元素腾出空间，需要花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;O(F)&lt;/span&gt;&lt;span&gt;以移动所有的元素。查找最佳元素操作会很快，因为它已经在末尾了所以花费是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。如果我们保证最佳排序至数组的尾部（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;best sorts to the&amp;nbsp;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;end&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;of the array&lt;/span&gt;&lt;span&gt;），删除最佳元素操作花费将是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。调整操作中，查找结点花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(logF)&lt;/span&gt;&lt;span&gt;，改变值&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;/&lt;/span&gt;&lt;span&gt;位置花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180961&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;排序链表&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在排序数组中，插入操作很慢。如果使用链表则可以加速该操作。集合关系检查操作很慢，需要花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;用于扫描链表。插入操作是很快的，插入新元素只花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;时间，但是查找正确位置需要花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。查找最佳元素很快，花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;时间，因为最佳元素已经在表的尾部。删除最佳元素也是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。调整操作中，查找结点花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;，改变值&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;/&lt;/span&gt;&lt;span&gt;位置花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180962&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;排序跳表&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在未排序链表中查找元素是很慢的。如果用跳表（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.wikipedia.org/wiki/Skip_list&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）代替链表的话，可以加速这个操作。在跳表中，如果有排序键（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;sort key&lt;/span&gt;&lt;span&gt;）的话，集合关系检查操作会很快：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;。如果你知道在何处插入的话，和链表一样，插入操作也是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。如果排序键是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;，查找最佳元素很快，达到&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;，删除一个元素也是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。调整操作涉及到查找结点，删除结点和重插入。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果我们用地图位置作为跳表的排序键，集合关系检查操作将是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;。在完成集合关系检查后，插入操作是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。查找最佳元素是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;，删除一个结点是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。因为集合关系检查更快，所以它比未排序链表要好一些。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果我们用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值作为跳表的排序键，集合关系检查操作将是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。插入操作是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。查找最佳元素是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;，删除一个结点是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。这并不比排序链表好。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180963&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.5&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;索引数组&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果结点的集合有限并且数目是适当的，我们可以使用直接索引结构，索引函数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;i(n)&lt;/span&gt;&lt;span&gt;把结点&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;映射到一个数组的索引。未排序与排序数组的长度等于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集的最大值，和它们不同，对所有的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;，索引数组的长度总是等于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;max(i(n))&lt;/span&gt;&lt;span&gt;。如果你的函数是密集的（没有不被使用的索引），&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;max(i(n))&lt;/span&gt;&lt;span&gt;将是你地图中结点的数目。只要你的地图是网格的，让索引函数密集就是容易的。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;假设&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;i(n)&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;的，集合关系检查将花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;，因为我们几乎不需要检查&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Array[i(n)]&lt;/span&gt;&lt;span&gt;是否包含任何数据。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Insertion is O(1), as we just ste&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Array[i(n)]&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;.&lt;/span&gt;&lt;span&gt;查找和删除最佳操作是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(numnodes)&lt;/span&gt;&lt;span&gt;，因为我们必须搜索整个结构。调整操作是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180964&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.6&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;哈希表&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;索引数组使用了很多内存用于保存不在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的所有结点。一个选择是使用哈希表。哈希表使用了一个哈希函数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h(n)&lt;/span&gt;&lt;span&gt;把地图上每个结点映射到一个哈希码。让哈希表的大小等于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;N&lt;/span&gt;&lt;span&gt;的两倍，以使发生冲突的可能性降低。假设&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;h(n)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;的，集体关系检查操作花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;；插入操作花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;；删除最佳元素操作花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(numnodes)&lt;/span&gt;&lt;span&gt;，因为我们需要搜索整个结构。调整操作花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180965&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.7&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;二元堆&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一个二元堆（不要和内存堆混淆）是一种保存在数组中的树结构。和许多普通的树通过指针指向子结点所不同，二元&lt;span class=&quot;GramE&quot;&gt;堆使用&lt;/span&gt;索引来查找子结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C++ STL&lt;/span&gt;&lt;span&gt;包含了一个二元堆的高效实现，我在我自己的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;代码中使用了它。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在二元堆中，集体关系检查花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;，因为你必须扫描整个结构。插入操作花费&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;而删除最佳操作花费也是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;调整操作很微妙（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;tricky&lt;/span&gt;&lt;span&gt;），花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;时间找到节点，并且很神奇，只用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;来调整。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我的一个朋友（他研究用于最短路径算法的数据结构）说，除非在你的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;fringe&lt;/span&gt;&lt;span&gt;集里有多于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10000&lt;/span&gt;&lt;span&gt;个元素，否则二元堆是很不错的。除非你的游戏地图特别大，否则你不需要更复杂的数据结构（如&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~csilvers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;multi-level buckets&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~csilvers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;http://www-cs-students.stanford.edu/~csilvers/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;））。你应该尽可能不用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Fibonacci&amp;nbsp;&lt;/span&gt;&lt;span&gt;堆（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.star-lab.com/goldberg/pub/neci-tr-96-062.ps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.star-lab.com/goldberg/pub/neci-tr-96-062.ps&lt;/a&gt;&lt;/span&gt;&lt;span&gt;），因为虽然它的渐近复杂度很好，但是执行起来很慢，除非&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F&lt;/span&gt;&lt;span&gt;足够大。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180966&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.8&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;伸展树&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;堆是一种基于树的结构，它有一个期望的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;代价的时间操作。然而，问题是在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法中，通常的情况是，一个代价小的节点被移除（花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;的代价，因为其他结点必须从树的底部向上移动），而紧接着一些代价小的节点被添加（花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;的代价，因为这些结点被添加到底部并且被移动到最顶部）。在这里，堆的操作在预期的情况下和最坏情况下是一样的。如果我们找到这样一种数据结构，最坏情况还是一样，而预期的情况好一些，那么就可以得到改进。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;伸展树（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Splay tree&lt;/span&gt;&lt;span&gt;）是一种自调整的树结构。任何对树结点的访问都尝试把该结点推到树的顶部（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;top&lt;/span&gt;&lt;span&gt;）。这就产生了一个缓存效果（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;“caching” effect&lt;/span&gt;&lt;span&gt;）：很少被使用的结点跑到底部（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;bottom&lt;/span&gt;&lt;span&gt;）去了并且不减慢操作（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;don’t slow down operations&lt;/span&gt;&lt;span&gt;）。你的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;splay&lt;/span&gt;&lt;span&gt;树有多大并不重要，因为你的操作仅仅和你的&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;cache size&lt;/span&gt;&lt;span&gt;&amp;rdquo;一样慢。在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;中，低代价的结点使用得很多，而高代价结点经常不被使用，所以高代价结点将会移动到树的底部。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;使用伸展树后，集体关系检查，插入，删除最佳和调整操作都是期望的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;（注：原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;expected O(log F)&amp;nbsp;&lt;/span&gt;&lt;span&gt;），最坏情况是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;。然而有代表性的是，缓存过程（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;caching&lt;/span&gt;&lt;span&gt;）避免了最坏情况的发生。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;算法和带有低估的启发函数（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;underestimating heuristic&lt;/span&gt;&lt;span&gt;）的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法却有一些特性让伸展树达不到最优。特别是对结点&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;/span&gt;&lt;span&gt;和邻居结点&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;来说，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n’) &amp;gt;= f(n)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;当这发生时，也许插入操作总是发生在树的同一边结果是使它失去了平衡。我没有试验过这个。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180967&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.9 HOT&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;队列&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;还有一种&lt;span class=&quot;GramE&quot;&gt;比堆好的&lt;/span&gt;数据结构。通常你可以限制优先队列中值的范围。给定一个限定的范围，经常会存在更好的算法。例如，对任意值的排序可以在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(N log N)&lt;/span&gt;&lt;span&gt;时间内完成，但当固定范围时，桶排序和基数排序可以在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(N)&lt;/span&gt;&lt;span&gt;时间内完成。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我们可以使用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Heap On Top&lt;/span&gt;&lt;span&gt;）队列&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;a href=&quot;http://www.star-lab.com/goldberg/pub&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.star-lab.com/goldberg/pub&lt;/a&gt; /neci-tr-97-104.ps&lt;/span&gt;&lt;span&gt;）来利用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n’) &amp;gt;= f(n)&lt;/span&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;span class=&quot;GramE&quot;&gt;&amp;rsquo;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;的一个邻居结点。我们删除&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n)&lt;/span&gt;&lt;span&gt;值最小的结点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;span&gt;，插入满足&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n) &amp;lt;= f(n’) &amp;lt;= f(n) + delta&lt;/span&gt;&lt;span&gt;的邻居&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;n’&lt;/span&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;delta &amp;lt;= C&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;常数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C&lt;/span&gt;&lt;span&gt;是从&lt;span class=&quot;GramE&quot;&gt;一&lt;/span&gt;结点到邻近结点代价改变量的最大值。因为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f(n)&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的最小&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值，并且正要被插入的所有结点都小于或等于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f(n) + delta&lt;/span&gt;&lt;span&gt;，我们知道&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的所有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;值都不超过一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;0..delta&lt;/span&gt;&lt;span&gt;的范围。在桶&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;&lt;span&gt;基数排序中，我们可以用&amp;ldquo;桶&amp;rdquo;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;buckets&lt;/span&gt;&lt;span&gt;）对&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的结点进行排序。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;桶，我们把&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(N)&lt;/span&gt;&lt;span&gt;的代价降低到平均&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(N/K)&lt;/span&gt;&lt;span&gt;。通过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列，顶端的&lt;span class=&quot;GramE&quot;&gt;桶使用&lt;/span&gt;二元堆而所有其他的桶都是未排序数组。因而，对顶部的桶，集合关系检查代价是预期的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F/K)&lt;/span&gt;&lt;span&gt;，插入和删除&lt;span class=&quot;GramE&quot;&gt;最佳是&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log (F/K))&lt;/span&gt;&lt;span&gt;。对其他桶，集合关系检查是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F/K)&lt;/span&gt;&lt;span&gt;，插入是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;，而删除最佳根本不发生！如果顶端的桶是空的，那么我们必须把下&lt;span class=&quot;GramE&quot;&gt;一个桶即未&lt;/span&gt;排序数组转换为二元堆。这个操作（&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;heapify&lt;/span&gt;&lt;span&gt;&amp;rdquo;）可以在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F/K)&lt;/span&gt;&lt;span&gt;时间内完成。在调整操作中，删除是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F/K)&lt;/span&gt;&lt;span&gt;，然后插入是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log (F/K))&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;中，我们加入&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的许多结点实际上根本是不需要的。在这方面&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列很有优势，因为不需要的元素的插入操作只花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;时间。只有需要的元素被&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;heapified&lt;/span&gt;&lt;span&gt;（代价较低的那些）。唯一&lt;span class=&quot;GramE&quot;&gt;一个&lt;/span&gt;超过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;的操作是从堆中删除结点，只花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log (F/K))&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另外，如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;C&lt;/span&gt;&lt;span&gt;比较小，我们可以只让&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;K = C&lt;/span&gt;&lt;span&gt;，则对于最小的桶，我们甚至不需要一个堆，国为在一个桶中的所有结点都有相同的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值。插入和删除&lt;span class=&quot;GramE&quot;&gt;最佳都是&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;时间！有人研究过，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列在至多在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中有&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;800&lt;/span&gt;&lt;span&gt;个结点时和&lt;span class=&quot;GramE&quot;&gt;堆一样&lt;/span&gt;快，并且如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中至多有&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1500&lt;/span&gt;&lt;span&gt;个结点，则&lt;span class=&quot;GramE&quot;&gt;比堆快&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;20%&lt;/span&gt;&lt;span&gt;。我期望随着结点的增加，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列也更快。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列的一个简单的变化是一个二层队列（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;two-level queue&lt;/span&gt;&lt;span&gt;）：把好的结点放进一个数据结构（堆或数组）而把坏的结点放进另一个数据结构（数组或链表）。因为大多数进入&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的结点都&amp;ldquo;坏的&amp;rdquo;，它们从不被检查，因而把它们放进出一个大数组是没有害处的。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180968&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.10&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;注意有一点很重要，我们并不是仅仅关心渐近的行为（大&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O&lt;/span&gt;&lt;span&gt;符号）。我们也需要关心小常数（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;low constant&lt;/span&gt;&lt;span&gt;）下的行为。为了说明原因，考虑一个&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;的算法，和另一个&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;的算法，其中&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F&lt;/span&gt;&lt;span&gt;是堆中元素的个数。也许在你的机器上，第一个算法的实现花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10000log(F)&lt;/span&gt;&lt;span&gt;秒，而另一个的实现花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;em&gt;F&lt;/em&gt;&lt;/span&gt;&lt;span&gt;秒。当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F=256&lt;/span&gt;&lt;span&gt;时，第一个算法将花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;80000&lt;/span&gt;&lt;span&gt;秒而第二个算法花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;512&lt;/span&gt;&lt;span&gt;秒。在这种情况下，&amp;ldquo;更快&amp;rdquo;的算法花费更多的时间，而且只有在当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F&amp;gt;200000&lt;/span&gt;&lt;span&gt;时才能运行得更快。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;你不能仅仅比较两个算法。你还要比较算法的实现。同时你还需要知道你的数据的大小（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;size&lt;/span&gt;&lt;span&gt;）。在上面的例子中，第一种实现在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F&amp;gt;200000&lt;/span&gt;&lt;span&gt;时更快，但如果在你的游戏中，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;F&lt;/span&gt;&lt;span&gt;小于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;30000&lt;/span&gt;&lt;span&gt;，那么第二种实现好一些。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;基本数据结构没有一种是完全合适的。未排序数组或者链表使插入操作很快而集体关系检查和删除操作非常慢。排序数组或者链表使集体关系检查稍微快一些，删除（最佳元素）操作非常快而插入操作非常慢。&lt;span class=&quot;GramE&quot;&gt;二元堆让插入&lt;/span&gt;和删除操作稍微快一些，而集体关系检查则很慢。伸展树让所有操作都快一些。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;HOT&lt;/span&gt;&lt;span&gt;队列让插入操作很快，删除操作相当快，而集体关系检查操作稍微快一些。索引数组让集体关系检查和插入操作非常快，但是删除操作不可置信地慢，同时还需要花费很多内存空间。哈希表和索引数组类似，但在普通情况下，它花费的内存空间少得多，而删除操作虽然还是很慢，但比索引数组要快。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;关于更高级的优先队列的资料和实现，请参考&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Lee Killough&lt;/span&gt;&lt;span&gt;的优先队列页面（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://members.xoom.com/killough/heaps.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://members.xoom.com/killough/heaps.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180969&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3.11&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;混合实现&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为了得到最佳性能，你将希望使用混合数据结构。在我的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;代码中，我使用一个索引数组从而集合关系检查是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;的，一个二元堆从而插入操作和删除&lt;span class=&quot;GramE&quot;&gt;最佳都是&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;的。对于调整操作，我使用索引数组从而花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(1)&lt;/span&gt;&lt;span&gt;时间检查我是否真的需要进行调整（通过在索引数组中保存&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g&lt;/span&gt;&lt;span&gt;值），然后在少数确实需要进行调整的情况中，我使用二元堆从而调整操作花费&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(F)&lt;/span&gt;&lt;span&gt;时间。你也可以使用索引数组保存堆中每个结点的位置，这让你的调整操作变成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;O(log F)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180970&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;与游戏循环的交互&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;交互式的（尤其是实时的）游戏对最佳路径的计算要求很高。能够得到一个解决方案比得到最佳方案可能更重要。然而在所有其他因素都相同的情况下，短路径比长路径好。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一般来说，计算靠近初始结点的路径比靠近目标结点的路径更重要一些。立即开始原理（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;The principle of&amp;nbsp;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;immediate start&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）：让游戏中的物体尽可能快地开始行动，哪怕是沿着一条不理想的路径，然后再计算一条更好的路径。在实时游戏中，应该更多地关注&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的延迟情况（&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;latency&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）而不是吞吐量（&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;throughput&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以对物体编程让它们根据自己的本能（简单行为）或者智力（一条预先计算好的路径）来行动。除非它们的智力告诉它们怎么行动，否则它们就根据自己的本能来行动（这是实际上使用的方法，并且&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Rodney Brook&lt;/span&gt;&lt;span&gt;在他的机器人体系结构中也用到）。和立即计算所有路径所不同，让游戏在每一个，两个，或者三个循环中搜索一条路径。让物体在开始时依照本能行动&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;&lt;span&gt;可能仅仅是简单地朝着目标直线前进&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;，然后才为它们寻找路径。这种方法让让路径搜索的代价趋于平缓，因此它不会集中发生在同一时刻。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180971&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.4.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;提前退出&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以从&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法的主循环中提前退出来同时得到一条局部路径。通常，当找到目标结点时，主循环就退出了。然而，在此之前的任意结点，可以得到一条到达&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;中当前最佳结点的路径。这个结点是到达目标点的最佳选择，所以它是一个理想的中间结点（原文为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;so it’s a reasonable place to go&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以提前退出的情况包括检查了一定数量的结点，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;算法已经运行了几毫秒时间，或者扫描了一个离初始&lt;span class=&quot;GramE&quot;&gt;点有些&lt;/span&gt;距离的结点。当使用路径拼接时，应该给被拼接的路径一个比全路径（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;full path&lt;/span&gt;&lt;span&gt;）小的最大长度。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180972&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.4.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;中断算法&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果需要进行路径搜索的物体较少，或者如果用于保存&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集的数据结构较小，那么保存算法的状态是可行的，然后退出到游戏循环继续运行游戏。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180973&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.4.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;组运动&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;路径请求并不是均匀分布的。即时策略游戏中有一个常见的情况，玩家会选择多个物体并命令它们朝着同样的目标移动。这给路径搜索系统以沉重的负载。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在这种情况下，为某个物体寻找到的路径对其它物体也是同样有用的。一种方法是，寻找一条从物体的中心到目的地中心的路径&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;P&lt;/span&gt;&lt;span&gt;。对所有物体使用该路径的绝大部分，对每一个物体，前十步和后十步使用为它自己寻找的路径。物体&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;i&lt;/span&gt;&lt;span&gt;得到一条从它的开始点到&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;P[10]&lt;/span&gt;&lt;span&gt;的路径，紧接着是共享的路径&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;P[10..len(P)-10]&lt;/span&gt;&lt;span&gt;，最后是从&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;P[len(P)-10]&lt;/span&gt;&lt;span&gt;到目的地的路径。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为每个物体寻找的路径是较短的（平均步数大约是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10&lt;/span&gt;&lt;span&gt;），而较长的路径被共享。大多数路径只寻找一次并且为所有物体所共享。然而，当玩家们看到所有的物体都沿着相同的路径移动时，将对游戏失去兴趣。为了对系统做些改进，可以让物体稍微沿着不同的路径运动。一种方法是选择邻近结点以改变路径。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另一种方法是让每个物体都意识到其它物体的存在（或许是通过随机选择一个&amp;ldquo;领导&amp;rdquo;物体，或者是通过选择一个能够最好地意识到当前情况的物体），同时仅仅为领导寻路。然后用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;flocking&lt;/span&gt;&lt;span&gt;算法让它们以组的形式运动。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;然而还有一种方法是利用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法的中间状态。这个状态可以被朝着相同目标移动的多个物体共享，只要物体共享相同的启发式函数和代价函数。当主循环退出时，不要消除&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集；用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;上一次的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集开始下一次的循环（下一个物体的开始位置）。（这可以被看成是中断算法和提前退出部分的一般化）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180974&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.4.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;细化&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果地图中没有障碍物，而有不同代价的地形，那么可以通过低估地形的代价来计算一条初始路径。例如，如果草地的代价是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;，山地代价是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;，山脉的代价是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;会考虑通过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3&lt;/span&gt;&lt;span&gt;个草地以避免&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;个山脉。通过把草地看成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;，山地看成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1.1&lt;/span&gt;&lt;span&gt;，而山脉看成&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1.2&lt;/span&gt;&lt;span&gt;来计算初始路径，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;将会用更少的时间去设法避免山脉，而且可以更快地找到一条路径（这接近于精确启发函数的效果）。一旦找到一条路径，物体就可以开始移动，游戏循环就可以继续了。当多余的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;时间是可用的时候，可以用真实的移动代价去计算更好的路径。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;a name=&quot;_Toc169180975&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4 A&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;算法的变种&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180976&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.1 beam search&lt;/span&gt;&lt;/a&gt;&amp;nbsp;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;font-family: &#39;Times New Roman&#39;;&quot;&gt;beam search&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的主循环中，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集保存所有需要检查的结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Beam Search&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法的一个变种，这种算法限定了&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集的尺寸。如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;集变得&lt;/span&gt;&lt;/span&gt;&lt;span&gt;过大，那些没有机会通向一条好的路径的结点将被抛弃。缺点是你必须让排序你的集合以实现这个，这限制了可供选择的数据结构。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180977&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;迭代深化&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;迭代深化是一种在许多&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;AI&lt;/span&gt;&lt;span&gt;算法中使用的方法，这种方法从一个近似解开始，逐渐得到更精确的解。该名称来源于游戏树搜索，需要查看前面几步（比如在象棋里），通过查看前面更多步来提高树的深度。一旦你的&lt;span class=&quot;GramE&quot;&gt;解不再&lt;/span&gt;有更多的改变或者改善，就可以认为你已经得到足够好的解，当你想要进一步精确化时，它不会再有改善。在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;ID-A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;中，深度是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值的一个&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;cutoff&lt;/span&gt;&lt;span&gt;。当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;的值太大时，结点甚至将不被考虑（例如，它不会被加入&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中）。第一次&lt;span class=&quot;GramE&quot;&gt;迭代只&lt;/span&gt;处理很少的结点。此后每一次迭代，访问的结点都将增加。如果你发现路径有所改善，那么就继续增加&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;cutoff&lt;/span&gt;&lt;span&gt;，否则就可以停止了。更多的细节请参考这些关于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;ID-A&lt;/span&gt;&lt;span&gt;的资料：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我本人认为在游戏地图中没有太大的必要使用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;ID-A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;寻路。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;ID&lt;/span&gt;&lt;span&gt;算法趋向于增加计算时间而减少内存需求。然而在地图路径搜索中，&amp;ldquo;结点&amp;rdquo;是很小的&amp;mdash;&amp;mdash;它们仅仅是坐标而已。我认为不保存这些结点以节省空间并不会带来多大改进。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180978&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;动态衡量&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在动态衡量中，你假设在开始搜索时，最重要的&lt;span class=&quot;GramE&quot;&gt;是讯速&lt;/span&gt;移动到任意位置；而在搜索接近结束时，最重要的是移动到目标点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;f(&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p) = g(p) + w(p)  h(p)&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;启发函数中带有一个权值（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;weight&lt;/span&gt;&lt;span&gt;）（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;w&amp;gt;=1&lt;/span&gt;&lt;span&gt;）。当你接近目标时，你降低这个权值；&lt;span class=&quot;GramE&quot;&gt;这降低&lt;/span&gt;了启发函数的重要性，同时增加了路径真实代价的相对重要性。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180979&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;带宽搜索&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;带宽搜索（&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;Bandwidth Search&lt;/span&gt;&lt;/em&gt;&lt;span&gt;）有两个对有些人也许有用的特性。这个变种假设&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h&lt;/span&gt;&lt;span&gt;是过高估计的值，但不高于某个数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;e&lt;/span&gt;&lt;span&gt;。如果这就是你遇到的情况，那么你得到的路径的代价将不会比最佳路径的代价超过&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;e&lt;/span&gt;&lt;span&gt;。重申一次，你的启发函数设计的越好，最终效果就越好。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另一个特性是，你可以丢弃&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的某些结点。当&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;h+d&lt;/span&gt;&lt;span&gt;比路径的真实代价高的时候（对于某些&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;d&lt;/span&gt;&lt;span&gt;），你可以丢弃那些&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值比&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中的最好结点的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值&lt;span class=&quot;GramE&quot;&gt;高至少&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;e+d&lt;/span&gt;&lt;span&gt;的结点。这是一个奇怪的特性。对于好的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;f&lt;/span&gt;&lt;span&gt;值你有一个&amp;ldquo;范围&amp;rdquo;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;“band”&lt;/span&gt;&lt;span&gt;），任何在这个范围之外的结点都可以被丢弃掉，因为这个结点肯定不会在最佳路径上。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;好奇地（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Curiously&lt;/span&gt;&lt;span&gt;），你可以对这两种特性使用不同的启发函数，而问题仍然可以得到解决。使用一个启发函数以保证你得到的路径不会太差，另一个用于检查从&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;集中去掉哪些结点。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180980&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.5&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;双向搜索&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;与从开始点向目标点搜索不同的是，你也可以并行地进行两个搜索&amp;mdash;&amp;mdash;一个从开始点向目标点，另一个从目标点&lt;span class=&quot;GramE&quot;&gt;向开始&lt;/span&gt;点。当它们相遇时，你将得到一条好的路径。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这听起来是个好主意，但我不会给你讲很多内容。双向搜索的思想是，搜索过程生成了一棵在地图上散开的树。一棵大树比两棵小树差得多，所以最好是使用两棵较小的搜索树。然而我的试验表明，在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;中你得不到一棵树，而只是在搜索地图中当前位置附近的区域，但是又不像&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Dijkstra&lt;/span&gt;&lt;span&gt;算法那样散开。事实上，这就是让&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;算法运行得如此快的原因&amp;mdash;&amp;mdash;无论你的路径有多长，它并不进行疯狂的搜索，除非路径是疯狂的。它只尝试搜索地图上小范围的区域。如果你的地图很复杂，双向搜索会更有用。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;面对面的方法（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;The&amp;nbsp;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;front-to-front&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN&quot;&gt;&amp;nbsp;variation&lt;/span&gt;&lt;span&gt;）把这两种搜索结合在一起。这种算法选择一对具有最好的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(start,x) + h(x,y) + g(y,goal)&lt;/span&gt;&lt;span&gt;的结点，而不是选择最好的前向搜索结点&amp;mdash;&amp;mdash;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(start,x) + h(x,goal)&lt;/span&gt;&lt;span&gt;，或者最好的后向搜索结点&amp;mdash;&amp;mdash;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;g(y,goal) + h(start,y)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Retargeting&lt;/span&gt;&lt;span&gt;方法不允许前向和后向搜索同时发生。它朝着某个最佳的中间结点运行前向搜索一段时间，然后再朝这个结点运行后向搜索。然后选择一个后向最佳中间结点，从前向最佳中间结点向后向最佳中间结点搜索。一直进行这个过程，直到两个中间结点碰到一块。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180981&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.6&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;动态&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;与终身计划&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;有一些&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的变种允许当初始路径计算出来之后，世界发生改变。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;用于当你没有全局所有信息的时候。如果你没有所有的信息，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;可能会出错；&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;的贡献在于，它能纠正那些错误而不用过多的时间。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;用于代价会改变的情况。在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;中，&lt;span class=&quot;GramE&quot;&gt;当地图发生&lt;/span&gt;改变时，路径将变得无效；&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;可以重新使用之前&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;的计算结果并产生新的路径。然而，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;/span&gt;&lt;span&gt;都需要很多内存&amp;mdash;&amp;mdash;用于运行&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;并保存它的内部信息（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集，路径树，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;g&lt;/span&gt;&lt;span&gt;值），&lt;span class=&quot;GramE&quot;&gt;当地图发生&lt;/span&gt;改变时，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;会告诉你，是否需要就地图的改变对路径作调整。在一个有许多运动着的物体的游戏中，你经常不希望保存所有这些信息，所以&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;在这里并不适用。它们是为机器人技术而设计的，这种情况下只有一个机器人&amp;mdash;&amp;mdash;你不需要为别的机器人寻路而重用内存。如果你的游戏只有一个或者少数几个物体，你可以研究一下&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;D&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;LPA&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;Overview of D&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;D&lt;em&gt; Paper 1&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;http:// &lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;D Paper 2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;http:// &lt;a href=&quot;http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://idm-lab.org/project-a.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;Lifelong planning overview&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://idm-lab.org/project-a.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://idm-lab.org/project-a.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://csci.mrs.umn.edu/UMMCSciWiki/pub/CSci3903s03/KellysPaper/seminar.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;Lifelong planning paper (PDF)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://csci.mrs.umn.edu/UMMCsciwiki/pub/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;http://csci.mrs.umn.edu/UMMCsciwiki/pub/&lt;/span&gt;&lt;/a&gt;&amp;nbsp;Csci3903s03/KellysPaper/seminar.pdf&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://idm-lab.org/applet.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;Lifelong planning A&lt;em&gt; applet&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;http://idm-lab.org/applet.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://idm-lab.org/applet.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;h1&gt;&lt;a name=&quot;_Toc169180982&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;处理运动障碍物&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一个路径搜索算法沿着固定障碍物计算路径，但是当障碍物会运动时情况又怎样？当一个物体到达一个特写的位置，原来的障碍物也许不再在那儿了，或者一个新的障碍物也许到达那儿。处理该问题的一个方法是放弃路径搜索而使用运动算法（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;movement algorithms&lt;/span&gt;&lt;span&gt;）替代，这就不能&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;look far ahead&lt;/span&gt;&lt;span&gt;；这种方法会在后面的部分中讨论。这一部分将对路径搜索方法进行修改从而解决运动障碍物的问题。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180983&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;重新计算路径&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当时间渐渐过去，我们希望游戏世界有所改变。以前搜索到的一条路径到现在也许不再是最佳的了。对旧的路径用新的信息进行更新是有价值的。以下规则可以用于决定什么时候需要重新计算路径：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;每&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;N&lt;/span&gt;&lt;span&gt;步：这保证用于计算路径的信息&lt;span class=&quot;GramE&quot;&gt;不会旧&lt;/span&gt;于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;N&lt;/span&gt;&lt;span&gt;步。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;任何可以使用额外的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;时间的时候：这允许动态调整路径的性质；在物体数量多时，或者运行游戏的机器比较慢时，每个物体对&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;的使用可得到减少。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当物体拐弯或者跨越一个导航点（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;waypoint&lt;/span&gt;&lt;span&gt;）的时候。&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当物体附近的世界改变了的时候。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;重计算路径的主要缺点是许多路径信息被丢弃了。例如，如果路径是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;100&lt;/span&gt;&lt;span&gt;步长，每&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10&lt;/span&gt;&lt;span&gt;步重新计算一次，路径的总步数将是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;100+90+80+70+60+50+40+30+20+10 = 550&lt;/span&gt;&lt;span&gt;。对&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;步长的路径，大约需要计算&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M^2&lt;/span&gt;&lt;span&gt;步。因此如果你希望有许多很长的路径，重计算不是个好主意。重新使用路径信息比丢弃它更好。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180984&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;路径拼接&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当一条路径需要被重新计算时，意味着世界正在改变。对于一个正在改变的世界，对地图中当前邻近的区域总是比对远处的区域了解得更多。因此，我们应该集中于在附近寻找好的路径，同时假设远处的路径不需要重新计算，除非我们接近它。与重新计算整个路径不同，我们可以重新计算路径的前&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;步：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;ol type=&quot;1&quot;&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;令&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[1]..p[N]&lt;/span&gt;&lt;span&gt;为路径（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;N&lt;/span&gt;&lt;span&gt;步）的剩余部分&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[1]&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[M]&lt;/span&gt;&lt;span&gt;计算一条新的路径&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;把这条新路径拼接（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Splice&lt;/span&gt;&lt;span&gt;）到旧路径：把&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[1]..p[M]&lt;/span&gt;&lt;span&gt;用新的路径值代替&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;br&gt;&lt;/ol&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;img src=&quot;http://theory.stanford.edu/~amitp/GameProgramming/mtn_path.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;因为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[1]&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;p[M]&lt;/span&gt;&lt;span&gt;比分开的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;步小（原文：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Since p[1] and p[M] are fewer than M steps apart&lt;/span&gt;&lt;span&gt;），看起来新路径不会很长。不幸的是，新的路径也许很长而且不够好。上面的图显示了这种情况。最初的红色路径是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1-2-3-4&lt;/span&gt;&lt;span&gt;，褐色的是障碍物。如果我们到达&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;并且发现从&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;到达&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3&lt;/span&gt;&lt;span&gt;的路径被封锁了，路径拼接技术会把&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2-3&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2-5-3&lt;/span&gt;&lt;span&gt;取代，结果是物体沿着路径&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1-2-5-3-4&lt;/span&gt;&lt;span&gt;运动。我们可以看到这不是一条好的路径，蓝色的路径&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1-2-5-4&lt;/span&gt;&lt;span&gt;是一条更好的路径。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;通常可以通过查看新路径的长度检测到坏的路径。如果这严格大于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;，就可能是不好的。一个简单的解决方法是，为搜索算法设置一个最大路径长度。如果找不到一条短的路径，算法返回错误代码；这种情况下，用重计算路径取代路径拼接，从而得到路径&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1-2-5-4.&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;对于其它情况，对于&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;N&lt;/span&gt;&lt;span&gt;步的路径，路径拼接会计算&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2N&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3N&lt;/span&gt;&lt;span&gt;步，这取决于拼接新路径的频率。对于对世界的改变作反应的能力而言，这个代价是相当低的。令人吃惊的是这个代价和拼接的步数&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;无关。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;不影响&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CPU&lt;/span&gt;&lt;span&gt;时间，而控制了响应和路径质量的折衷。如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;太大，物体的移动将不能快速对地图的改变&lt;span class=&quot;GramE&quot;&gt;作出&lt;/span&gt;反应。如果&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;太小，拼接的路径可能太短以致不能正确地绕过障碍物；许多不理想的路径（如&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1-2-5-3-4&lt;/span&gt;&lt;span&gt;）将被找到。尝试不同的&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;值和不同的拼接标准&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;&lt;span&gt;如每&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3/4&amp;nbsp;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;M&lt;/span&gt;&lt;/em&gt;&lt;span&gt;步&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;，看看哪一种情况对你的地图最合适。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;路径拼接确实比重计算路径要快，但它不能对路径的改变&lt;span class=&quot;GramE&quot;&gt;作出&lt;/span&gt;很好的反应。经常可以发现这种情况并用路径重计算来取代。也可以调整一些变量，如&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;M&lt;/span&gt;&lt;span&gt;和寻找新路径的时机，所以可以对该方法进行调整&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;&lt;span&gt;甚至在运行时&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;以用于不同的情况。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Note&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Bryan Stout&amp;nbsp;&lt;/span&gt;&lt;span&gt;有两个算法，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Patch-One&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Patch-All&lt;/span&gt;&lt;span&gt;，他从路径拼接中得到灵感，并在实践中运行得很好。他出席了&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;https://www.cmpevents.com/GD07/a.asp?option=C&amp;amp;V=11&amp;amp;SessID=4608&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;span&gt;GDC 2007&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;a href=&quot;https://www.cmpevents.com/GD07/a.asp?option&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.cmpevents.com/GD07/a.asp?option&lt;/a&gt; =C &amp;amp;V=11&amp;amp; SessID=4608&lt;/span&gt;&lt;span&gt;）；一旦他把资料放在网上，我将链接过去。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Implementation Note&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;反向保存路径，从而删除路径的开始部分并用不同长度的新路径拼接将更容易，因为这两个操作都将在数组的末尾进行。本质上你可以把这个数组看成是堆栈因为顶部的元素总是下一个要使用的。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180985&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;监视地图变化&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;与间隔一段时间重计算全部或部分路径不同的是，可以让地图的改变触发一次重计算。地图可以分成区域，每个物体都可以对某些区域感兴趣（可以是包含部分路径的所有区域，也可以只是包含部分路径的邻近区域）。当一个障碍物进入或者离开一个区域，该区域将被标识为已改变，所有对该区域感兴趣的物体都被通知到，所以路径将被重新计算以适应障碍物的改变。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这种技术有许多变种。例如，可以每隔一定时间通知物体，而不是立即通知物体。多个改变可以成组地触发一个通知，因此避免了额外的重计算。另一个例子是，让物体检查区域，而不是让区域通知物体。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;监视地图变化允许当障碍物不改变时物体避免重计算路径，所以当你有许多区域并不经常改变时，考虑这种方法。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180986&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;预测障碍物的运动&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果障碍物的运动可以预测，就能为路径搜索考虑障碍物的未来位置。一个诸如&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;的算法有一个代价函数用以检查穿过地图上一点的代价有多难。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;可以被改进从而知道到达一点的时间需求（通过当前路径长度来检查），而现在则轮到代价函数了。代价函数可以考虑时间，并用预测的障碍物位置检查在某个时刻地图某个位置是否可以通过。这个改进不是完美的，然而，因为它并不考虑在某个点等待障碍物自动离开的可能性，同时&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A&lt;/span&gt;&lt;span&gt;并不区分到达相同目的地的不同的路径，而是针对不同的目的地，所以还是可以接受的。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;a name=&quot;_Toc169180987&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;预计算路径的空间代价&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h1&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;有时，路径计算的限制因素不是时间，而是用于数以百计的物体的存储空间。路径搜索器需要空间以运行算法和保存路径。算法运行所需的临时空间（在&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;A*&lt;/span&gt;&lt;span&gt;中是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span&gt;集）通常比保存结果路径的空间大许多。通过限制在一定的时间计算一条路径，可以把临时空间数量最小化。另外，为&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;OPEN&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;CLOSED&lt;/span&gt;&lt;span class=&quot;GramE&quot;&gt;&lt;span&gt;集所选择&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的数据结构的不同，最小&lt;span class=&quot;GramE&quot;&gt;化临时&lt;/span&gt;空间的程度也有很大的不同。这一部分聚集于优化用于计算路径的空间代价。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180988&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;位置&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;VS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;方向&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一条路径可以&lt;span class=&quot;GramE&quot;&gt;用位置&lt;/span&gt;或者方向来表示。位置需要更多的空间，但是有一个优点，易于查询路径中的任意位置或者方向而不用沿着路径移动。当保存方向时，只有方向容易被查询；只有沿着整个路径移动才能查询位置。在&lt;span class=&quot;GramE&quot;&gt;一个典形的&lt;/span&gt;网格地图中，位置可以被保存为两个&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;16&lt;/span&gt;&lt;span&gt;位整数，每走一步是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;32&lt;/span&gt;&lt;span&gt;位。而方向是很少的，因此用极少的空间就够了。如果物体只能沿着四个方向移动，每一步用两位就够了；如果物体能沿着&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;6&lt;/span&gt;&lt;span&gt;个或者&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;8&lt;/span&gt;&lt;span&gt;个方向移动，每一步也只需要三位。这些对于保存路径中的位置都有明显的空间节省。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Hannu Kankaanpaa&lt;/span&gt;&lt;span&gt;指出可以进一步减少空间需求，那就是保存相对方向（右旋&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;60&lt;/span&gt;&lt;span&gt;度）而不是绝对方向（朝北走）。有些相对方向对某些物体来说意义不大。比如，如果你的物体朝北移动，那么下一步朝南移动的可能性很小。在只有六种方向的游戏中，你只有五个有意义的方向。在某些地图中，也许只有三个方向（直走，左旋&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;60&lt;/span&gt;&lt;span&gt;度，右旋&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;60&lt;/span&gt;&lt;span&gt;度）有意义，而其它地图中，右旋&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;120&lt;/span&gt;&lt;span&gt;度是有效的（比如，沿着陡峭的山坡走之字形的路径时）。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180989&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;路径压缩&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一旦找到一条路径，可以对它进行压缩。可以用一个普通的压缩算法，但这里不进行讨论。使用特定的压缩算法可以缩小路径的存储，无论它是基于位置的还是基于方向的。在做决定之前，考察你的游戏中的路径以确定哪种压缩效果最好。另外还要考虑实现和调试，代码量，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;and whether it really matters.&lt;/span&gt;&lt;span&gt;如果你有&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;300&lt;/span&gt;&lt;span&gt;个物体并且在同一时刻只有&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;50&lt;/span&gt;&lt;span&gt;个在移动，同时路径比较短（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;100&lt;/span&gt;&lt;span&gt;步），内存总需求大概只有不到&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;50k&lt;/span&gt;&lt;span&gt;，总之，没有必要担心压缩的效果。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180990&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.2.1&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;位置存储&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在障碍物比地形对路径搜索影响更大的地图中，路径中有大部分是直线的。如果是这种情况，那么路径只需要包含直线部分的终止点（有时叫&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;waypoints&lt;/span&gt;&lt;span&gt;）。此时移动过程将包含检查下一结点和沿着直线向前移动。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;a name=&quot;_Toc169180991&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.2.2&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;方向存储&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h3&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;保存方向时，有一种情况是同一个方向保存了很多次。可以用简单的方法节省空间。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一种方法是保存方向以及&lt;span class=&quot;GramE&quot;&gt;朝着该&lt;/span&gt;方向移动的次数。和位置存储的优化不同，当一个方向并不是移动很多次时，这种优化的效果反而不好。同样的，对于那些可以进行位置压缩的直线来说，方向压缩是行不通的，因为这条直线可能没有和正在移动的方向关联。通过相对方向，你可以把&amp;ldquo;继续前进&amp;rdquo;当作可能的方向排除掉。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Hannu Kankaanpaa&lt;/span&gt;&lt;span&gt;指出，在一个八方向地图中，你可以去掉前，后，以及向左和向右&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;135&lt;/span&gt;&lt;span&gt;度（假设你的地图允许这个），然后你可以仅用两个比特保存每个方向。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;另一种保存路径的方法是变长编码。这种想法是使用一个简单的比特（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;0&lt;/span&gt;&lt;span&gt;）保存最一般的步骤：向前走。使用一个&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;&amp;rdquo;表示拐弯，后边再跟几个比特表示拐弯的方向。在一个&lt;span class=&quot;GramE&quot;&gt;四方向&lt;/span&gt;地图中，你只能左转和右转，因此可以用&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10&lt;/span&gt;&lt;span&gt;&amp;rdquo;表示左转，&amp;ldquo;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;11&lt;/span&gt;&lt;span&gt;&amp;rdquo;表示右转。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;变长编码比&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;run length encoding&lt;/span&gt;&lt;span&gt;更一般，并且可以压缩得更好，但对于较长的直线路径则不然。序列（向北直走&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;6&lt;/span&gt;&lt;span&gt;步，左转，直走&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;3&lt;/span&gt;&lt;span&gt;步，右转，直走&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;5&lt;/span&gt;&lt;span&gt;步，左转，直走&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;步）用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;run length encoding&lt;/span&gt;&lt;span&gt;表示是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;[(NORTH, 6), (WEST, 3), (NORTH, 5), (WEST, 2)]&lt;/span&gt;&lt;span&gt;。如果每个方向用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;比特，每个距离用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;8&lt;/span&gt;&lt;span&gt;比特，保存这条路径需要&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;40&lt;/span&gt;&lt;span&gt;比特。而对于变长编码，你用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;比特表示每一步，&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;2&lt;/span&gt;&lt;span&gt;比特表示拐弯&amp;mdash;&amp;mdash;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;[NORTH 0 0 0 0 0 0 10 0 0 0 11 0 0 0 0 0 10 0 0]&lt;/span&gt;&lt;span&gt;&amp;mdash;&amp;mdash;一共&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;24&lt;/span&gt;&lt;span&gt;比特。如果初始方向和每次拐弯对应&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;1&lt;/span&gt;&lt;span&gt;步，则每次拐弯都节省了一个比特，结果只需要&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;20&lt;/span&gt;&lt;span&gt;比特保存这条路径。然而，用变长编码保存更长的路径时需要更多的空间。序列&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;(&lt;/span&gt;&lt;span&gt;向北直走&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;200&lt;/span&gt;&lt;span&gt;步&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;run length encoding&lt;/span&gt;&lt;span&gt;表示是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;[(NORTH, 200)]&lt;/span&gt;&lt;span&gt;，总共需要&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;10&lt;/span&gt;&lt;span&gt;比特。用变长编码表示同样的序列则是&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;[NORTH 0 0 …]&lt;/span&gt;&lt;span&gt;，一共需要&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;202&lt;/span&gt;&lt;span&gt;比特。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180992&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.3&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;计算导航点&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一个导航点（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;waypoint&lt;/span&gt;&lt;span&gt;）是路径上的一个结点。与保存路径上的每一步不同，在进行路径搜索之后，一个后处理（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;post-processing&lt;/span&gt;&lt;span&gt;）的步骤可能会把若干步&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;collapse&lt;/span&gt;&lt;span&gt;（译者：不好翻译，保留原单词）为一个简单的导航点，这经常发生在路径上那些方向发生改变的地方，或者在一个重要的（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;major&lt;/span&gt;&lt;span&gt;）位置如城市。然后运动算法将在两个导航点之间运行。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180993&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.4&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;极限路径长度&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当地图中的条件或者秩序会发生改变时，保存一条长路径是没有意义的，因为在从某些点开始，后边的路径已经没有用了。每个物体都可以保存路径开始时的特定几步，然后当路径已经没用时重新计算路径。这种方法虑及了（&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;allows for&lt;/span&gt;&lt;span&gt;）对每个物体使用数据的总量的管理。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;a name=&quot;_Toc169180994&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.5&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;br&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在游戏中，路径潜在地花费了许多存储空间，特别是当路径很长并且有很多物体需要寻路时。路径压缩，导航点和&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;beacons&lt;/span&gt;&lt;span&gt;通过把多个步骤保存为一个较小数据从而减少了空间需求。&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;Waypoints rely on straight-line segments being common so that we have to store only the endpoints, while beacons rely on there being well-known paths calculated beforehand between specially marked places on the map.&lt;/span&gt;&lt;span&gt;（译者：此处不好翻译，暂时保留原文）如果路径仍然用了许多存储空间，可以限制路径长度，这就回到了经典的时间&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;-&lt;/span&gt;&lt;span&gt;空间折衷法：为了节省空间，信息可以被丢弃，稍后才重新计算它。&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;/p&gt;&lt;br&gt;&lt;/div&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先，这篇文章是转发的，如果我有侵权行为，请给我发邮件或者在文章底下留言，我会在24小时以内删除O(∩_∩)O&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/b2b160/article/details/4057781&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="分享" scheme="http://zhaoleyi.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="模板" scheme="http://zhaoleyi.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="A*" scheme="http://zhaoleyi.github.io/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>bzoj4325斗地主</title>
    <link href="http://zhaoleyi.github.io/2016/04/12/bzoj4325%E6%96%97%E5%9C%B0%E4%B8%BB/"/>
    <id>http://zhaoleyi.github.io/2016/04/12/bzoj4325斗地主/</id>
    <published>2016-04-12T01:23:05.000Z</published>
    <updated>2016-05-03T12:11:29.344Z</updated>
    
    <content type="html">&lt;p&gt;首先，这道题是noip2015提高组DAY1T3，但是为了方便查找，所以我放了题号作为标题&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;首先这道题目经过一些interesting的变化，所以代码有些长，同时思维复杂度以及代码复杂度有些高，需要耐心看完&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：3&amp;lt;4&amp;lt;5&amp;lt;6&amp;lt;7&amp;lt;8&amp;lt;9&amp;lt;10&amp;lt;J&amp;lt;Q&amp;lt;K&amp;lt;A&amp;lt;2&amp;lt;小王&amp;lt;大王，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由n张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。&lt;br&gt;现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。&lt;br&gt;需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。&lt;br&gt;具体规则如下：&lt;br&gt;&lt;img src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/11.PNG&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; class=&quot;headerlink&quot; title=&quot;输入格式：  &quot;&gt;&lt;/a&gt;输入格式：  &lt;/h2&gt;&lt;p&gt;第一行包含用空格隔开的2个正整数T,N，表示手牌的组数以及每组手牌的张数。  &lt;/p&gt;
&lt;p&gt;接下来T组数据，每组数据N行，每行一个非负整数对Ai,Bi，表示一张牌，其中Ai表示牌的数码,Bi表示牌的花色，中间用空格隔开。特别的，我们用1来表示数码A，11表示数码J，12表示数码Q，13表示数码K；黑桃、红心、梅花、方片分别用1-4来表示；小王的表示方法为01，大王的表示方法为02。  &lt;/p&gt;
&lt;h2 id=&quot;输出格式：&quot;&gt;&lt;a href=&quot;#输出格式：&quot; class=&quot;headerlink&quot; title=&quot;输出格式：  &quot;&gt;&lt;/a&gt;输出格式：  &lt;/h2&gt;&lt;p&gt;共T行，每行一个整数，表示打光第T组手牌的最少次数。  &lt;/p&gt;
&lt;h2 id=&quot;输入样例-1：&quot;&gt;&lt;a href=&quot;#输入样例-1：&quot; class=&quot;headerlink&quot; title=&quot;输入样例#1：  &quot;&gt;&lt;/a&gt;输入样例#1：  &lt;/h2&gt;&lt;p&gt;1 8&lt;br&gt;7 4&lt;br&gt;8 4&lt;br&gt;9 1&lt;br&gt;10 4&lt;br&gt;11 1&lt;br&gt;5 1&lt;br&gt;1 4&lt;br&gt;1 1  &lt;/p&gt;
&lt;h2 id=&quot;输出样例-1：&quot;&gt;&lt;a href=&quot;#输出样例-1：&quot; class=&quot;headerlink&quot; title=&quot;输出样例#1：  &quot;&gt;&lt;/a&gt;输出样例#1：  &lt;/h2&gt;&lt;p&gt;3&lt;/p&gt;
&lt;h2 id=&quot;输出样例-1解释：&quot;&gt;&lt;a href=&quot;#输出样例-1解释：&quot; class=&quot;headerlink&quot; title=&quot;输出样例#1解释：  &quot;&gt;&lt;/a&gt;输出样例#1解释：  &lt;/h2&gt;&lt;p&gt;共有1组手牌，包含8张牌：方片7，方片8，黑桃9，方片10，黑桃J，黑桃5，方片A以及黑桃A。可以通过打单顺子（方片7，方片8，黑桃9，方片10，黑桃J），单张牌（黑桃5）以及对子牌（黑桃A以及方片A）在3次内打光。  &lt;/p&gt;
&lt;h2 id=&quot;输入样例-2：&quot;&gt;&lt;a href=&quot;#输入样例-2：&quot; class=&quot;headerlink&quot; title=&quot;输入样例#2：  &quot;&gt;&lt;/a&gt;输入样例#2：  &lt;/h2&gt;&lt;p&gt;1 17&lt;br&gt;12 3&lt;br&gt;4 3&lt;br&gt;2 3&lt;br&gt;5 4&lt;br&gt;10 2&lt;br&gt;3 3&lt;br&gt;12 2&lt;br&gt;0 1&lt;br&gt;1 3&lt;br&gt;10 1&lt;br&gt;6 2&lt;br&gt;12 1&lt;br&gt;11 3&lt;br&gt;5 2&lt;br&gt;12 4&lt;br&gt;2 2&lt;br&gt;7 2&lt;br&gt;输出样例#2：&lt;br&gt;6  &lt;/p&gt;
&lt;h2 id=&quot;数据规定&quot;&gt;&lt;a href=&quot;#数据规定&quot; class=&quot;headerlink&quot; title=&quot;数据规定:  &quot;&gt;&lt;/a&gt;数据规定:  &lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;测试点编号&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;测试点编号&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;n &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;    1&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    2&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    3&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    4&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    5&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    6&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    7&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    8&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;    9&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;   10&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;题目看完了吗？嘿嘿嘿，这道题目会比你想象的还要复杂，耐心打，大概2kb左右就可以完成了&lt;/p&gt;
&lt;h1 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h1&gt;&lt;p&gt;首先在知道思路之前，必须先知道在给定的规则之外还有三张牌可以带大小王中的&lt;strong&gt;任意一张&lt;/strong&gt;（没错，必须只有一张）。同时还有炸弹带的牌里面可以包括任意张数的王。&lt;br&gt;&lt;strong&gt;同时还有更重要的地方，一付炸弹可以带两幅对子，和正常的斗地主不一样&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;首先，大家都知道&lt;del&gt;谋财害命&lt;/del&gt;的CCF为了这道题目开了1G内存，2s时限，所以可以放心大胆的爆搜。我的做法是首先搜索在当前状态下有顺子的话先打出顺子，为了方便的话，我先搜索单顺子的，然后是双顺子的，接着是三顺子的。&lt;br&gt;在搜索顺子之后，要搜索炸弹，和上面的想法类似，搜索炸弹的时候首先要搜索炸弹带两对对子的情况，然后是炸弹带两张单拍，最后递归纯炸弹的情况。&lt;br&gt;继续，然后搜索三只牌，先查找三只牌带一对对子的情况，然后是三只牌带一张单拍，最后才递归只出三张牌的情况。&lt;br&gt;一个小的减枝：在前面的搜索中记录一下除了单拍和对子的情况是否出现过，如果没有的话，那么说明在剩下的牌里面，只有单拍和对子那么可以O(n)处理答案，与当前的最优解进行比较，同时退出当前的这种搜索。&lt;/p&gt;
&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;102&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;103&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;104&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;105&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;106&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;107&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;108&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;109&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;110&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;112&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;113&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;114&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;115&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;116&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;117&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;118&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;119&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;120&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;121&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;122&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;124&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;125&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;126&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;127&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;128&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;129&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;130&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;131&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;133&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;135&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;136&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;137&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;139&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;140&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;141&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;142&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;143&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;144&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;145&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;146&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;147&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;148&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;149&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;150&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;151&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;152&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;153&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;154&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;155&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include&amp;lt;cstdio&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include&amp;lt;cstring&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;using namespace std;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int t,n;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int ans;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int card[20];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//从1到11表示3到K,12表示A,13表示2。14表示小王，15表示大王&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void shunzi(int l,int r,int cut)\\这个函数是用来方便地从l到r中间的card数组进行减操作，cut是表示减掉的个数（代表出掉了几张牌）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (int i=l;i&amp;lt;=r;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 card[i]=card[i]-cut;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void dfs(int temp,int nn)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (temp&amp;gt;ans)\\最优性减枝&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 return;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (nn==0)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123; if (temp&amp;lt;ans)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  ans=temp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      return;&amp;#125;	  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (int i = 1; i &amp;lt;= 13; i++)//顺子左边界&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (card[i] == 0)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		for (int j = i + 1; j &amp;lt;= 12; j++)//单顺子右边界 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (!card[j])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				break;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (j - i &amp;lt; 4)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			else shunzi(i, j, 1), dfs(temp + 1, nn - (j - i + 1)), shunzi(i, j, -1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		for (int j = i; j &amp;lt;= 12; j++)//双顺子右边界&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (card[j] &amp;lt; 2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				break;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (j - i &amp;lt; 2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			else shunzi(i, j, 2), dfs(temp + 1, (nn - (j - i + 1)) * 2), shunzi(i, j, -2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		for (int j = i; j &amp;lt;= 12; j++)//三顺子右边界&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (card[j] &amp;lt; 3)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				break;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (j - i &amp;lt; 1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			else shunzi(i, j, 3), dfs(temp + 1, (nn - (j - i + 1)) * 3), shunzi(i, j, -3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	bool flag=false;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (int i = 1; i &amp;lt;= 13; i++)//炸弹左边界&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (card[i] == 4)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			for (int j = 1; j &amp;lt;= 14; j++)//炸弹带两对对子&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				if (j == i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				else if (card[j] &amp;gt;= 2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] -= 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					flag = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[j] -= 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					for (int k = 1; k &amp;lt;= 14; k++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						if (k == i || k == j)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						else if (card[k]&amp;gt;=2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						     &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;								 card[k] -= 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;								 dfs(temp + 1, nn - 8);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;								 card[k] += 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] += 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[j] += 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			for (int j = 1; j &amp;lt;= 14; j++)//炸弹带两只单牌&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				if (j == i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				else if (card[j] &amp;gt;= 1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] -= 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[j] -= 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					for (int k = 1; k &amp;lt;= 14; k++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						if (k == i || k == j)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						else if (card[k] &amp;gt;= 1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							card[k] -= 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							flag = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							dfs(temp + 1, nn - 6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;							card[k] += 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;						&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[j] += 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] += 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			card[i] -= 4;//炸弹不带&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			dfs(temp + 1, nn - 4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			card[i] += 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (int i = 1; i &amp;lt;= 13; i++)//三只左边界&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (card[i] &amp;gt;= 3)//3带几&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			for (int j = 1; j &amp;lt;= 13; j++)//3带对子&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				if (j == i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				else if (card[j] &amp;gt;= 2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] -= 3, card[j] -= 2,flag=true, dfs(temp + 1, nn - 5), card[i] += 3, card[j] += 2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			for (int j = 1; j &amp;lt;= 14; j++)//3带1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				if (j == i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				else if (card[j] &amp;gt;= 1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					card[i] -= 3, card[j] -= 1, flag=true,dfs(temp + 1, nn - 4), card[i] += 3, card[j] += 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			card[i] -= 3;//3不带&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			dfs(temp + 1, nn - 3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			card[i] += 3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	int tt=0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (!flag)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		for (int i = 1; i &amp;lt;= 14; i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			if (card[i] != 0)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				tt++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (temp + tt &amp;lt; ans)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			ans = temp + tt; return;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		else return;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;   	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	scanf(&quot;%d%d&quot;,&amp;amp;t,&amp;amp;n);\\读入，没啥好说的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (int I=1;I&amp;lt;=t;I++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 memset(card,0,sizeof(card));\\一定要初始化，不然会滑稽的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 int xx1,xx2;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 for (int i=1;i&amp;lt;=n;i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  scanf(&quot;%d%d&quot;,&amp;amp;xx1,&amp;amp;xx2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  if (xx1==0)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			card[14]++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  if (xx1 &amp;gt;= 3)card[xx1 - 2]++;\\目的是为了按照正常的牌的大小进行排列。3最小，2最大（除了王）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  if (xx1 &amp;lt;3 )card[xx1 + 11]++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 ans=2147483;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     dfs(0,n);\\第一个参数表示进行操作的步数，第二个表示当前还剩下的牌的个数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 printf(&quot;%d\n&quot;,ans);\\一定要记得换行&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;p&gt;做这道题目的时候不要性急，只要慢慢来，一定可以AC的。↖(^ω^)↗&lt;br&gt;&lt;em&gt;如果对于我的博文有任何的建议或意见，可以选择在文章下面评论或者发邮件给我，我的邮箱在右侧栏的站点概览中有链接&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先，这道题是noip2015提高组DAY1T3，但是为了方便查找，所以我放了题号作为标题&lt;br&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://zhaoleyi.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="noip" scheme="http://zhaoleyi.github.io/tags/noip/"/>
    
  </entry>
  
  <entry>
    <title>转：关于春游的报道</title>
    <link href="http://zhaoleyi.github.io/2016/04/12/%E8%BD%AC%EF%BC%9A%E5%85%B3%E4%BA%8E%E6%98%A5%E6%B8%B8%E7%9A%84%E6%8A%A5%E9%81%93/"/>
    <id>http://zhaoleyi.github.io/2016/04/12/转：关于春游的报道/</id>
    <published>2016-04-12T01:14:17.000Z</published>
    <updated>2016-04-12T01:27:59.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章转自hcz神犇，他摘自新华社&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;em&gt;新华社4月11日报道：&lt;/em&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;em&gt;绍兴市第一中学党支部书记与学校高层在不知道什么时候进行的不知道有没有进行的会议中决定，高一至高三以及创新班同学将于今日下午出发远足，而作为本校&lt;/em&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;&lt;em&gt;撑面子&lt;/em&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;em&gt;的信竞同学则留校学习。&lt;/em&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;em&gt;本次会议做出的决定深刻贯彻落实了党中央在十八大提出的“不给信竞人权”的政策方针，是各高校值得学习的榜样。&lt;/em&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;em&gt;作为带教老师，董野花做出了很好的表率作用。抛下信竞同学不管，自己去远足。这种精神值得每一个老师学习！&lt;/em&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;呵&lt;em&gt;&lt;br&gt;&lt;/em&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; font-size: 18px;&quot;&gt;呵呵&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; font-size: 20px;&quot;&gt;呵呵呵&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; font-size: 24px;&quot;&gt;呵呵呵呵&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; font-size: 24px;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; font-size: 16px;&quot;&gt;今天绍一的高一高二高三创新班很happy的去远足，诸中的高一高二高三提前班还在放假，七院的OI狗早早就在机房码题。&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through; font-size: 16px;&quot;&gt;信竞没人权&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;text-decoration: none; font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;上午在其他人没来前，小店也没开。要知道，我们OI狗可是小店重要的资金来源，一个OI狗的消费力≈3*高中狗。&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;信竞没人权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;上午在其他人没来前，食堂只开一个。并且也就开寥寥几个窗。&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;信竞没人权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;诸中放四天，绍一放4天&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;（搞得我们好像不是绍一的一样好吧我们是七院附中）&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;,OI狗放一天，还是周日。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;信竞没人权&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;text-decoration: none; font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;今天远足前，校领导还用话筒发表讲话，&lt;strong&gt;用话筒&lt;/strong&gt;。很明显就是给我们听的，虽然我没有听清，但他的意思应该大致是：哈哈哈你们这群OI狗看看我们我们远足去辣你来咬我呀啦啦啦啦啦啦你咬不到我我们在远足呵呵呵呵&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;text-decoration: none; font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;信竞没人权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;其实我们也可以去“远足”，我们可以去七院啊！&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://7xrxql.com1.z0.glb.clouddn.com/1460373972582283.png&quot; alt=&quot;avatar&quot;&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;信竞没人权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;来来来科普一下七院：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;绍兴市第七人民医院创建于1956年，是一所既具有精神、心理专科优势，又具有综合医疗服务功能的三级乙等专科医院。医院承担着绍兴市及周边地区精神心理疾病的医疗、教学、预防、康复、科研和危机干预等工作。&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;由于医院在精神心理疾病方面的日益强大，现已将绍兴市第一中学收入编制，将其改名为绍兴市第七人民医院附属中学。简称七院附中。&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: line-through;&quot;&gt;看看别人都是学校附属医院我们是医院附属中学我们多强哈哈哈哈&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;由于收录了绍兴市第一中学（现称七院附中），医院等级破格提升至三级特等，为绍兴地区最高等级医院。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;em&gt;&lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;PS.斜体部分纯属口胡，如有雷同，那就?的是真的了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;最后，和我一起膜大神加RP：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;%RZZ；%RXD；%JRY；%FF；%HZQ；%HHD；%JSB；%DYH；%DHH；%DHX；%YJN；%WWT；%WYX；%BDF；%JYT；%FHW；%JHN；%ZYF；%ZZH；%ZYH；%GN；%SLY；%SJY；%TZN；%SXR&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, &amp;#39;Microsoft YaHei&amp;#39;; text-decoration: none;&quot;&gt;还有很多神犇膜不过来了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;    &lt;span style=&quot;font-family:微软雅黑, Microsoft YaHei&quot;&gt;md我是不是智障……&lt;/span&gt;&lt;br&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章转自hcz神犇，他摘自新华社&lt;br&gt;
    
    </summary>
    
    
      <category term="funny" scheme="http://zhaoleyi.github.io/tags/funny/"/>
    
      <category term="分享" scheme="http://zhaoleyi.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>黄学长博客镜像</title>
    <link href="http://zhaoleyi.github.io/2016/04/11/%E9%BB%84%E5%AD%A6%E9%95%BF%E5%8D%9A%E5%AE%A2%E9%95%9C%E5%83%8F/"/>
    <id>http://zhaoleyi.github.io/2016/04/11/黄学长博客镜像/</id>
    <published>2016-04-11T02:12:58.000Z</published>
    <updated>2016-04-11T03:25:54.000Z</updated>
    
    <content type="html">&lt;p&gt;经过大圣神犇两个晚上的辛勤劳作，终于把黄学长的博客抓起镜像到本地了。╰(&lt;em&gt;°▽°&lt;/em&gt;)╯&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;想法起源&quot;&gt;&lt;a href=&quot;#想法起源&quot; class=&quot;headerlink&quot; title=&quot;想法起源&quot;&gt;&lt;/a&gt;想法起源&lt;/h1&gt;&lt;p&gt;首先，大家都知道，黄学长的博客是一个非常好的地方，但是苦于没有流量，或者手机没有信号，在某些特殊的地方不能访问黄学长的博客&lt;br&gt;导致刷B站&lt;del&gt;(BZOJ)&lt;/del&gt;的时候就停住了。然后由于大圣非常强，所以会写JS代码，于是我把这个想法交给了大圣。&lt;/p&gt;
&lt;h1 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://ec28c5.lt.yunpan.cn/lk/cqtwncytCbvt5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大数字云盘&lt;/a&gt;(提取码ed04)&lt;br&gt;&lt;a href=&quot;http://pan.baidu.com/s/1jIyEkqa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;度娘盘&lt;/a&gt;(提取码4n2q)&lt;/p&gt;
&lt;h1 id=&quot;号召&quot;&gt;&lt;a href=&quot;#号召&quot; class=&quot;headerlink&quot; title=&quot;号召&quot;&gt;&lt;/a&gt;号召&lt;/h1&gt;&lt;p&gt;首先，我建议我们集体对大圣进行膜拜，同时，我觉得我们应该给大圣买他最爱吃的薯片，同时请有博客的神犇们请把大圣加到自己的友链里。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;经过大圣神犇两个晚上的辛勤劳作，终于把黄学长的博客抓起镜像到本地了。╰(&lt;em&gt;°▽°&lt;/em&gt;)╯&lt;br&gt;
    
    </summary>
    
    
      <category term="日常日记" scheme="http://zhaoleyi.github.io/tags/%E6%97%A5%E5%B8%B8%E6%97%A5%E8%AE%B0/"/>
    
      <category term="分享" scheme="http://zhaoleyi.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>转：搞懂树状数组</title>
    <link href="http://zhaoleyi.github.io/2016/04/06/%E8%BD%AC%EF%BC%9A%E6%90%9E%E6%87%82%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://zhaoleyi.github.io/2016/04/06/转：搞懂树状数组/</id>
    <published>2016-04-06T08:12:51.000Z</published>
    <updated>2016-04-06T08:43:53.000Z</updated>
    
    <content type="html">&lt;p&gt;首先，此文转载自CSDN上一位大牛的博客，地址是：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/int64ago/article/details/7429868&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/int64ago/article/details/7429868&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于我不会线段树，树状数组等一系列BALABALA的东西，所以今天的模拟赛萎掉了，然后痛定思痛，开始充电（我也不知道是快速的还是慢速的）&lt;/p&gt;
&lt;h1 id=&quot;正文（转）&quot;&gt;&lt;a href=&quot;#正文（转）&quot; class=&quot;headerlink&quot; title=&quot;正文（转）&quot;&gt;&lt;/a&gt;正文（转）&lt;/h1&gt;&lt;p&gt;写下这个标题，其实心里还是没底的，与其说是写博帖，不如说是做总结。第一个接触树状数组还是两年前，用什么语言来形容当时的感觉呢？……太神奇了！真的，无法表达出那种感觉，她是那么的优雅，10行不到的代码，却把事情干的如此出色！没有了解她原理的前提下即使把代码倒背如流也理解不了！其中，我就是一直没搞懂地在使用她。时隔两年，又无意遇到了她，可能是两年的代码经验的积累，有了些新的认识，可以自信的说理解了吧！下面我争取用自己的方式让更多人明白她，而不是背诵她。为了更方便的说明，文章里会自己强加一些概念，只是为了更好的理解，不是什么专业术语之类的。&lt;/p&gt;
&lt;h2 id=&quot;树状数组是干什么的？&quot;&gt;&lt;a href=&quot;#树状数组是干什么的？&quot; class=&quot;headerlink&quot; title=&quot;树状数组是干什么的？&quot;&gt;&lt;/a&gt;树状数组是干什么的？&lt;/h2&gt;&lt;p&gt;平常我们会遇到一些对数组进行维护查询的操作，比较常见的如，修改某点的值、求某个区间的和，而这两种恰恰是树状数组的强项！当然，数据规模不大的时候，对于修改某点的值是非常容易的，复杂度是O(1)，但是对于求一个区间的和就要扫一遍了，复杂度是O(N)，如果实时的对数组进行M次修改或求和，最坏的情况下复杂度是O(M×N)，当规模增大后这是划不来的！而树状数组干同样的事复杂度却是O(M×lgN)，别小看这个lg，很大的数一lg就很小了，这个学过数学的都知道吧，不需要我说了。申明一下，看下面的文章一定不要急，只需要看懂每一步最后自然就懂了。&lt;/p&gt;
&lt;h2 id=&quot;树状数组怎么干的？&quot;&gt;&lt;a href=&quot;#树状数组怎么干的？&quot; class=&quot;headerlink&quot; title=&quot;树状数组怎么干的？&quot;&gt;&lt;/a&gt;树状数组怎么干的？&lt;/h2&gt;&lt;p&gt;先看两幅图（网上找的，如果雷同，不要大惊小怪～），下面的说明都是基于这两幅图的，上边的叫A图吧，下边的叫B图：&lt;br&gt;&lt;img src=&quot;http://my.csdn.net/uploads/201204/05/1333629700_5876.jpg&quot; alt=&quot;avatar&quot;&gt; &lt;img src=&quot;http://my.csdn.net/uploads/201204/05/1333629705_5541.png&quot; alt=&quot;avatar&quot;&gt;&lt;br&gt;是不是很像一颗树？对，这就是为什么叫树状数组了～先看A图，a数组就是我们要维护和查询的数组，但是其实我们整个过程中根本用不到a数组，你可以把它当作一个摆设！c数组才是我们全程关心和操纵的重心。先由图来看看c数组的规则，其中c8 = c4+c6+c7+a8，c6 = c5+a6……先不必纠结怎么做到的，我们只要知道c数组的大致规则即可，很容易知道c8表示a1～a8的和，但是c6却是表示a5～a6的和，为什么会产生这样的区别的呢？或者说发明她的人为什么这样区别对待呢？答案是，这样会使操作更简单！看到这相信有些人就有些感觉了，为什么复杂度被lg了呢？可以看到，c8可以看作a1～a8的左半边和+右半边和，而其中左半边和是确定的c4，右半边其实也是同样的规则把a5～a8一分为二……继续下去都是一分为二直到不能分，可以看看B图。怎么样？是不是有点二分的味道了？对，说白了树状数组就是巧妙的利用了二分，她并不神秘，关键是她的巧妙！&lt;br&gt;她又是怎样做到不断的一分为二呢？说这个之前我先说个叫lowbit的东西，lowbit(k)就是把k的二进制的高位1全部清空，只留下最低位的1,比如10的二进制是1010,则lowbit(k)=lowbit(1010)=0010(2进制)，介于这个lowbit在下面会经常用到，这里给一个非常方便的实现方式，比较普遍的方法lowbit(k)=k&amp;amp;-k，这是位运算，我们知道一个数加一个负号是把这个数的二进制取反+1，如-10的二进制就是-1010=0101+1=0110，然后用1010&amp;amp;0110，答案就是0010了！明白了求解lowbit的方法就可以了，继续下面。介于下面讨论十进制已经没有意义（这个世界本来就是二进制的，人非要主观的构建一个十进制），下面所有的数没有特别说明都当作二进制。&lt;br&gt;上面那么多文字说lowbit，还没说它的用处呢，它就是为了联系a数组和c数组的！ck表示从ak开始往左连续求lowbit(k)个数的和，比如c[0110]=a[0110]+a[0101]，就是从110开始计算了0010个数的和，因为lowbit(0110)=0010，可以看到其实只有低位的1起作用，因为很显然可以写出c[0010]=a[0010]+a[0001]，这就为什么我们任何数都只关心它的lowbit，因为高位不起作用（基于我们的二分规则它必须如此！），除非除了高位其余位都是0，这时本身就是lowbit。&lt;br&gt;既然关系建立好了，看看如何实现a某一个位置数据跟改的，她不会直接改的（开始就说了，a根本不存在），她每次改其实都要维护c数组应有的性质，因为后面求和要用到。而维护也很简单，比如更改了a[0011]，我们接着要修改c[0011],c[0100],c[1000]，这是很容易从图上看出来的，但是你可能会问，他们之间有申明必然联系吗？每次求解总不能总要拿图来看吧？其实从0011——&amp;gt;0100——&amp;gt;1000的变化都是进行“去尾”操作，又是自己造的词–’’，我来解释下，就是把尾部应该去掉的1都去掉转而换到更高位的1,记住每次变换都要有一个高位的1产生，所以0100是不能变换到0101的，因为没有新的高位1产生，这个变换过程恰好是可以借助我们的lowbit进行的，k +=lowbit(k)。&lt;br&gt;好吧，现在更新的次序都有了，可能又会产生新的疑问了：为什么它非要是这种关系啊？这就要追究到之前我们说c8可以看作a1～a8的左半边和+右半边和……的内容了，为什么c[0011]会影响到c[0100]而不会影响到c[0101]，这就是之前说的c[0100]的求解实际上是这样分段的区间 c[0001]~c[0001] 和区间c[0011]~c[0011]的和，数字太小，可能这样不太理解，在比如c[0100]会影响c[1000]，为什么呢？因为c[1000]可以看作0001～0100的和加上0101~1000的和，但是0101位置的数变化并会直接作用于c[1000]，因为它的尾部1不能一下在跳两级在产生两次高位1,是通过c[0110]间接影响的，但是，c[0100]却可以跳一级产生一次高位1。&lt;br&gt;可能上面说的你比较绕了，那么此时你只需注意：c的构成性质（其实是分组性质）决定了c[0011]只会直接影响c[0100]，而c[0100]只会直接影响[1000]，而下表之间的关系恰好是也必须是k +=lowbit(k)。此时我们就是写出跟新维护树的代码：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt;  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(k&amp;lt;=n)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        tree[k]+=num;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        k+=k&amp;amp;-k;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有了上面的基础，说求和就比较简单了。比如求0001～0110的和就直接c[0100]+c[0110]，分析方法与上面的恰好逆过来，而且写法也是逆过来的，具体就不累述了：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//1~k的区间和  &lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(k)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sum+=tree[k];  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        k-=k&amp;amp;-k;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结一下吧&quot;&gt;&lt;a href=&quot;#总结一下吧&quot; class=&quot;headerlink&quot; title=&quot;总结一下吧&quot;&gt;&lt;/a&gt;总结一下吧&lt;/h2&gt;&lt;p&gt;首先，明白树状数组所白了是按照二分对数组进行分组；维护和查询都是O(lgn)的复杂度，复杂度取决于最坏的情况，也是O(lgn);lowbit这里只是一个技巧，关键在于明白c数组的构成规律;分析的过程二进制一定要深入人心，当作心目中的十进制。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先，此文转载自CSDN上一位大牛的博客，地址是：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/int64ago/article/details/7429868&quot;&gt;http://blog.csdn.net/int64ago/article/details/7429868&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://zhaoleyi.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模板" scheme="http://zhaoleyi.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
